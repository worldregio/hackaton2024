[
  {
    "objectID": "02-agregation-sociale.html",
    "href": "02-agregation-sociale.html",
    "title": "Agrégation sociale",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\n# Packages d'enquête\n#library(xtable)\n#library(survey)\nlibrary(questionr)"
  },
  {
    "objectID": "02-agregation-sociale.html#objectifs",
    "href": "02-agregation-sociale.html#objectifs",
    "title": "Agrégation sociale",
    "section": "Objectifs",
    "text": "Objectifs\nDans ce premier exercice on ne va pas s’intéresser à la géographie des logements sociaux mais à leur sociologie. On va donc croiser la variable Y = ménages résidant dans un logement social avec d’autres variables X1 ..Xn décrivant les attributs des ménages et chercher s’il existe des relations statistiquement significatives.\n\nFormuler des questions ou des hypothèses\nQu’elles soient justes ou fausses, les hypothèses permettent de cadrer l’analyse.\n\nDiplôme et logement social : Les logements sociaux sont-ils réservés aux ménages les moins diplômés ?\nÂge et logement social : Les logements sociaux sont-ils réservés aux jeunes ménages ?\nLogement social, âge et diplômes : Les personnes diplômés quittent-elles les logements sociaux dès que leurs revenus progressent\n\n\n\nOrganiser le travail\nSutout dans le cadre d’un groupe !\n\nNe collecter que les données utiles pour répondre aux questions posées afin de ne pas être tenté de partir dans toutes les directions\nArchiver soigneusement les programmes et les résultats afin de pouvoir reproduire ultérieurement les analyses sur une autre période, un autre territoire\nNe pas attendre d’avoir accumulé tous les résultats pour les commenter car l’analyse peut suggérer des erreurs ou ouvrir de nouvelles pistes.\nPartir des questions et non pas des outils faute de quoi on va trouver des réponses (42 …) sans savoir quelle est la question.\n\n\n\nChargement des données\n\n\nCode\ntab_ind&lt;-readRDS(\"res/tabmen.RDS\")\n\nhead(tab_ind[,1:5],2)\n\n\nFALSE   X COMMUNE   ARM      IRIS ACHL\nFALSE 1 1   13055 13201 132010101  B11\nFALSE 2 2   13055 13201 132010101  A12\n\n\n\n\nRéviser ses cours de statistiques …\nSelon la nature des variables X et Y vous devrez faire appel à des méthodes statistiques différentes. Nous allons donner ici deux exemples différents"
  },
  {
    "objectID": "02-agregation-sociale.html#exemple-1-logement-hlm-et-diplôme",
    "href": "02-agregation-sociale.html#exemple-1-logement-hlm-et-diplôme",
    "title": "Agrégation sociale",
    "section": "Exemple 1 : Logement HLM et diplôme",
    "text": "Exemple 1 : Logement HLM et diplôme\n\nPréparation de l’analyse\n\nSoit la relation entre logement en HLM (Y) et Diplôme le plus élevé du chef de ménage (X). Il s’agit de deux variables catégorielles (= qualitatives) que l’on va typiquement mettre en relation à l’aide d’un tableau de contingence et d’un test du chi-2. L’analyse statistique est simple sous R mais il faut tenir compte de trois difficultés\nLe choix de la population de référence est important. Ici on va sélectionner les ménages dont la personne de référence est âgée de 25-39 ans\nla sélection ou le regroupement des diplômes est également important car cela va influer sur les résultats du test.\nla pondération des individus doit également être prise en compte puisque le recensement est basé sur un sondage\n\n\n\nSélection des individus et des variables\n\n\nCode\ntab_sel&lt;- tab_ind %&gt;% \n  filter(AGEMEN8 == \"25\") %&gt;%\n  select(DIPLM,HLML, IPONDL) \n\n\nknitr::kable(head(tab_sel,4))\n\n\n\n\n\nDIPLM\nHLML\nIPONDL\n\n\n\n\n15\n2\n2.48657\n\n\n15\n2\n2.48657\n\n\n18\n2\n2.48657\n\n\n18\n2\n2.48657\n\n\n\n\n\n\n\nRecodage des modalités\nOn cherche le code des modalités CS1 ezt HLML dans le fichier des métadonnées\n\n\nCode\nmeta&lt;-readRDS(\"res/tabmen_meta.RDS\")\nmetasel &lt;- meta %&gt;% filter(COD_VAR %in% c(\"DIPLM\", \"HLML\"))\nkable(metasel[,c(1,3,4)])\n\n\n\n\n\n\n\n\n\n\nCOD_VAR\nCOD_MOD\nLIB_MOD\n\n\n\n\nDIPLM\n01\nPas de scolarité ou arrêt avant la fin du primaire\n\n\nDIPLM\n02\nAucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\n\n\nDIPLM\n03\nAucun diplôme et scolarité jusqu’à la fin du collège ou au-delà\n\n\nDIPLM\n11\nCEP (certificat d’études primaires)\n\n\nDIPLM\n12\nBEPC, brevet élémentaire, brevet des collèges, DNB\n\n\nDIPLM\n13\nCAP, BEP ou diplôme de niveau équivalent\n\n\nDIPLM\n14\nBaccalauréat général ou technologique, brevet supérieur, capacité en droit, DAEU, ESEU\n\n\nDIPLM\n15\nBaccalauréat professionnel, brevet professionnel, de technicien ou d’enseignement, diplôme équivalent\n\n\nDIPLM\n16\nBTS, DUT, Deug, Deust, diplôme de la santé ou du social de niveau bac+2, diplôme équivalent\n\n\nDIPLM\n17\nLicence, licence pro, maîtrise, diplôme équivalent de niveau bac+3 ou bac+4\n\n\nDIPLM\n18\nMaster, DEA, DESS, diplôme grande école niveau bac+5, doctorat de santé\n\n\nDIPLM\n19\nDoctorat de recherche (hors santé)\n\n\nDIPLM\nYY\nHors résidence principale\n\n\nHLML\n1\nLogement appartenant à un organisme HLM\n\n\nHLML\n2\nLogement n’appartenant pas à un organisme HLM\n\n\nHLML\nY\nHors résidence principale\n\n\n\n\n\nOn recode les modalités des deux variables en regroupant certaines CSP\n\n\nCode\ntab_sel$HLML&lt;-as.factor(tab_sel$HLML)\nlevels(tab_sel$HLML)&lt;-c(\"HLM-O\",\"HLM-N\",NA)\ntab_sel$DIPLM&lt;-as.factor(tab_sel$DIPLM)\nlevels(tab_sel$DIPLM) &lt;- c(\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\n                         \"BAC\",\"BAC\",\n                         \"BAC+123\",\"BAC+123\",\"&gt; BAC+3\",\"&gt; BAC+3\",NA)\ntable(tab_sel$DIPLM)\n\n\nFALSE \nFALSE   &lt; BAC     BAC BAC+123 &gt; BAC+3 \nFALSE   12206    7423   10379    9766\n\n\nCode\nknitr::kable(head(tab_sel,3))\n\n\n\n\n\nDIPLM\nHLML\nIPONDL\n\n\n\n\nBAC\nHLM-N\n2.48657\n\n\nBAC\nHLM-N\n2.48657\n\n\n&gt; BAC+3\nHLM-N\n2.48657\n\n\n\n\n\n\n\nCréation du tableau de contingence non pondéré (FAUX)\nLa solution la plus simple semble être l’instruction table()\n\n\nCode\ntab_cont&lt;-table(tab_sel$HLML,tab_sel$DIPLM)\n\nknitr::kable(addmargins(tab_cont))\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nSum\n\n\n\n\nHLM-O\n3314\n1319\n931\n439\n6003\n\n\nHLM-N\n8892\n6104\n9448\n9327\n33771\n\n\nSum\n12206\n7423\n10379\n9766\n39774\n\n\n\n\n\n\n\nCréation du tableau de contingence pondéré (JUSTE)\nOn pondère avec wtd.table() du package questionr.\n\n\nprogramme\n\n\nCode\nlibrary(questionr)\ntab_cont_wtd&lt;-wtd.table(tab_sel$HLML,tab_sel$DIPLM,\n                        weights = tab_sel$IPONDL)\n\nknitr::kable(round(addmargins(tab_cont_wtd),0))\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nSum\n\n\n\n\nHLM-O\n7538\n2898\n2096\n960\n13492\n\n\nHLM-N\n22318\n14339\n21648\n21557\n79862\n\n\nSum\n29855\n17237\n23744\n22518\n93354\n\n\n\n\n\n\n\nComparaison des résultats en %\n\nTableau non pondéré … légèrement faux !\n\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nAll\n\n\n\n\nHLM-O\n27.2\n17.8\n9\n4.5\n15.1\n\n\nHLM-N\n72.8\n82.2\n91\n95.5\n84.9\n\n\nTotal\n100.0\n100.0\n100\n100.0\n100.0\n\n\n\n\n\n\nTableau pondéré … juste !\n\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nAll\n\n\n\n\nHLM-O\n25.2\n16.8\n8.8\n4.3\n14.5\n\n\nHLM-N\n74.8\n83.2\n91.2\n95.7\n85.5\n\n\nTotal\n100.0\n100.0\n100.0\n100.0\n100.0\n\n\n\n\n\n\n\nVisualisation du tableau de contingence\nOn choisit l’orientation du tableau et on l’affiche avec plot()\n\n\nCode\nmytable&lt;-wtd.table(tab_sel$DIPLM,tab_sel$HLML,weights = tab_sel$IPONDL)\nplot(mytable)\n\n\n\n\n\nTant qu’à faire, on améliore la figure avec des paramètres supplémentaires :\n\n\n\n\n\n\n\nTest du Chi-deux\nCe test se réalise facilement sur le tableau de contingence avec l’instruction chisq.test() :\n\n\nCode\nmytest&lt;-chisq.test(mytable)\nmytest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  mytable\nX-squared = 5389.3, df = 3, p-value &lt; 2.2e-16\n\n\nLa lecture de la p-value permet de savoir s’il existe une relation significative entre les deux variables.\n\n\nVisualisation des résidus\nLorsque la relation est significative, on peut visualiser les cases les plus exceptionnelles avec mosaicplot( …, shade = T)"
  },
  {
    "objectID": "02-agregation-sociale.html#exemple-2-hlm-et-ancienneté-doccupation",
    "href": "02-agregation-sociale.html#exemple-2-hlm-et-ancienneté-doccupation",
    "title": "Agrégation sociale",
    "section": "Exemple 2 : HLM et ancienneté d’occupation",
    "text": "Exemple 2 : HLM et ancienneté d’occupation\nDans ce deuxième exemple, on se propose d’analyser si les habitants des HLM y résident depuis plus longtemps que les habitants d’autres types de logements. On va donc calculer leur ancienneté moyenne puis déterminer à l’aide d’un test d’égalité des moyennes s’il y a des différences significatives.\nNous devons comme précédemment tenir compte des pondérations\n\nPréparation des données\n\n\nCode\ntab_sel&lt;- tab_ind  %&gt;%\n  select(ANEM,HLML,IPONDL) %&gt;% \n  filter(ANEM != \"999\") %&gt;%\n  mutate(ANEM = as.numeric(ANEM)) \n\ntab_sel$HLML&lt;-as.factor(tab_sel$HLML)\nlevels(tab_sel$HLML)&lt;-c(\"Oui\",\"Non\")\nhead(tab_sel)\n\n\n  ANEM HLML  IPONDL\n1   11  Non 2.48657\n2   12  Non 2.48657\n3   10  Non 2.48657\n4   81  Non 2.48657\n5   10  Non 2.48657\n6    1  Non 2.48657\n\n\n\n\nStatistiques non pondérées\nOn peut commencer par une description rapide sans pondération :\n\n\nCode\ntapply(tab_sel$ANEM, tab_sel$HLML, summary)\n\n\n$Oui\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    3.00    8.00   13.73   20.00   88.00 \n\n$Non\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    0.0     2.0     5.0    12.1    18.0   101.0 \n\n\nOn découvre - avec surprise - que l’ancienneté d’occupation des ménages qui résdient en HLM est plus importante que celle des autres ménages. Est-ce une erreur liée à l’absence de pondération ?\n\n\nMoyenne et ecart-types pondérés\nOn calcule la moyenne et l’écart-type pondérés à l’aide du package weights.\n\n\nCode\nlibrary(weights,quietly = T, verbose=F)\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:questionr':\n\n    describe, wtd.mean, wtd.table, wtd.var\n\n\nThe following objects are masked from 'package:dplyr':\n\n    src, summarize\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units\n\n\nCode\ntab_sel %&gt;% group_by(HLML) %&gt;%\n           summarise(moyenne=wtd.mean(ANEM,IPONDL),\n                     variance = wtd.var(ANEM,IPONDL),\n                     ectype = sqrt(variance))\n\n\n# A tibble: 2 × 4\n  HLML  moyenne variance ectype\n  &lt;fct&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n1 Oui      15.1     202.   14.2\n2 Non      13.5     228.   15.1\n\n\nLes valeurs sont différentes mais la conclusion demeure la même : les ménages qui résident en HLM y sont depuis plus longtemps que les autres. Toutefois l’écart-type est également tr§s grand ce qui incité à visualiser les distributions.\n\n\nBoxplot\n\n\nCode\nggplot(data = tab_sel)+ aes(x=ANEM, y = HLML) +\n      geom_boxplot() +\n      scale_x_continuous(\"Ancienneté d'occupation (en année)\") +\n      scale_y_discrete(\"Ménages logés en HLM\") +\n      ggtitle(\"Ancienneté d'occupation selon la résdience en HLM à Marseille\",\n              subtitle = \"Source : INSEE RP 2020\") + \n      theme_gray()\n\n\n\n\n\nIl y a effectivement un décalage, aussi bien pour la moyenne, la médiane et les quartiles. Pour conclure on va donc réaliser un test.\n\n\nTest d’égalité des moyennes\n\n\nCode\nt.test(ANEM~HLML, data=tab_sel)\n\n\n\n    Welch Two Sample t-test\n\ndata:  ANEM by HLML\nt = 17.777, df = 41032, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group Oui and group Non is not equal to 0\n95 percent confidence interval:\n 1.447961 1.806821\nsample estimates:\nmean in group Oui mean in group Non \n         13.72549          12.09810 \n\n\nOn peut conclure cette fois-ci sans risque d’erreur (p &lt; 0.001) que les habitants des HLM y résident depuis plus longtemps que ceux des autres logements à Marseille en 2020."
  },
  {
    "objectID": "01-Data.html",
    "href": "01-Data.html",
    "title": "Préparation des données",
    "section": "",
    "text": "Code\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      message = FALSE, \n                      error=FALSE)\nlibrary(knitr)\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(data.table,warn.conflicts = F, verbose=F)\n\n\nWarning: package 'data.table' was built under R version 4.3.3\n\n\nCode\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE"
  },
  {
    "objectID": "01-Data.html#introduction",
    "href": "01-Data.html#introduction",
    "title": "Préparation des données",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "01-Data.html#rp-logement-2020-insee",
    "href": "01-Data.html#rp-logement-2020-insee",
    "title": "Préparation des données",
    "section": "RP Logement 2020 (INSEE)",
    "text": "RP Logement 2020 (INSEE)\nNous partons des fichiers détail de l’INSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement d’indicateurs. Ils sont évidemment très volumineux mais ici vous avez la chance de bénéficier d’une extraction des communes sur lesquelles vous allez travailler\n\nEtape 1 : Importation des données au format R\nComme les fichiers sont d’assez petite taille, on se contentera d’utiliser la fonctionread.csv qui fait partie du R-base :\n\n\nCode\nt1&lt;-Sys.time()\ntab&lt;-read.csv(\"data/rplogmt_13055.csv\")\nt2&lt;-Sys.time()\npaste (\"chargement effectué en\",t2-t1,\"secondes\")\ndim(tab)\nclass(tab)\n\n\nDans l’exemple choisi (Marseille) le tableau ne comporte que 182735 individus et se charge en moins d’une seconde\nToutefois, si vous êtes amenés à traiter directement des fichiers de l’INSEE comportant plusieurs millions d’enregistrement vous aurez intérêt à utiliser des fonctions plus puissantes comme la fonction read_csv2 du package readr ou, miuex encore, la fonction fread du package data.table\n\n\nEtape 2 : Sélection des données utiles et sauvegarde au format .RDS\nNos tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format .csv qui pèse en général beaucoup plus.\nComme ces données vont nous servir durant tout le projet, elles seront stockées dans le dossier res qui sera spécifique à l’exemple retenu.\n\n\nCode\n## Sauvegarde au format RDS\nsaveRDS(object = tab,\n        file = \"res/tabmen.RDS\")\n\n\n\nEtape 3 : Chargement et sauvegarde des méta-données\nIl ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis l’enregistrer également dans le dossier res. Noter qu’on utilise cette fois-ci la fonction read.csv2car le séparateur de colonne n’est plus la virgule (ce qu’on lit avec read.csv) mais le point virgule.\n\n\nCode\n# Lecture du fichier de métadonnées\nmeta&lt;-read.csv2(\"meta/Dictionnaire variables_logemt_2020.csv\")\n# Enregistrement dans le dossier data\nsaveRDS(object = meta,\n        file = \"res/tabmen_meta.RDS\")"
  },
  {
    "objectID": "01-Data.html#géométries-2020-ign",
    "href": "01-Data.html#géométries-2020-ign",
    "title": "Préparation des données",
    "section": "Géométries 2020 (IGN)",
    "text": "Géométries 2020 (IGN)\nLes contours des unités spatiales correspondant aux codes de l’INSEE sont produits par l’IGN et disponibles sur le site géoservice en accès libre. En général on récupère un très gros fichier pour la France entière ce qui demande un peu de travail pour extraire juste la zone d’étude. Ici vous avez de la chance puisqu’on vous a déjà extrait le fichier relatif à votre commune\n\nEtape 1 : Importation et transformation au format sf\nLa cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois\n\nun tableau de données (l’équivalent du fichier .dbf)\nune géométrie (l’équivalent du fichier .shp)\nune projection (l’équivalent du fichier .prj)\n\nLorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf.\n\n\nCode\nlibrary(sf)\nmap_iris &lt;- st_read(\"data/iris_13055.gml\")\n\n\nReading layer `iris_13055' from data source \n  `/Users/claudegrasland1/worldregio/hackaton2024/data/iris_13055.gml' \n  using driver `GML'\nSimple feature collection with 393 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 881250.9 ymin: 6232998 xmax: 905587.3 ymax: 6257715\nProjected CRS: RGF93 Lambert 93\n\n\nCode\ndim(map_iris)\n\n\n[1] 393   8\n\n\nCode\nclass(map_iris)\n\n\n[1] \"sf\"         \"data.frame\"\n\n\nCode\nhead(map_iris,2)\n\n\nSimple feature collection with 2 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 892700.6 ymin: 6245602 xmax: 893856.1 ymax: 6246686\nProjected CRS: RGF93 Lambert 93\n        gml_id INSEE_COM                     NOM_COM IRIS CODE_IRIS\n1 iris_13055.0     13206 Marseille 6e Arrondissement  301 132060301\n2 iris_13055.1     13206 Marseille 6e Arrondissement  602 132060602\n        NOM_IRIS TYP_IRIS               geometryProperty\n1        Bergers        H MULTIPOLYGON (((893856.1 62...\n2 Vauban-Fénelon        H MULTIPOLYGON (((892867.6 62...\n\n\nPour faciliter la compatibilité avec d’autres applications, la 8e colonne qui contient le contour des zones est renommée “geometry” plutôt que “geometryProperty”.\n\n\nCode\nst_geometry(map_iris) &lt;-\"geometry\"\n\n\n\n\nEtape 2 : Visualisation des IRIS de la zone d’étude\nLe nouveau tableau ne comporte plus que 393 unités spatiales et 8 colonnes On peut visualiser rapidement le résultat à l’aide de la fonction plotdu package sf :\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry)\n\n\n\n\n\nOn sauvegarde le résultat dans notre dossier res au format interne de R :\n\n\nCode\nsaveRDS(object = map_iris,\n        file = \"res/map_iris.RDS\")\n\n\n\n\nEtape 3 : Carte des arrondissements\nComme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des arrondissements en utilisant les fonctions d’agrégation du packages sf combinées avec celles de dplyr.\n\n\nCode\nmap_arr &lt;- map_iris  %&gt;% group_by(INSEE_COM) %&gt;%\n                        summarise(NOM_COM = min(NOM_COM)) %&gt;%\n                        st_as_sf()\n\n\non vérifie que l’agrégation s’est bien passée :\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_arr$geometry)\n\n\n\n\n\nEt on sauvegarde le fonds de carte\n\n\nCode\nsaveRDS(object = map_arr,\n        file = \"res/map_arr.RDS\")\n\n\n\n\nEtape 4 : création d’un contour complet de la commune\nEnfin, on construit un fonds de carte de l’ensemble de la commune étudiée\n\n\nCode\n# Agrégation\nmap_com &lt;- map_iris  %&gt;%     mutate(tot = \"Marseille\") %&gt;%\n                        group_by(tot) %&gt;%\n                        summarise() %&gt;%\n                        st_as_sf()\n# Visualisation\npar(mar=c(0,0,0,0))\nplot(map_com$geometry)\n\n\n\n\n\nCode\n# Sauvegarde\nsaveRDS(object = map_com,\n        file = \"res/map_com.RDS\")\n\n\n\n\nEtape 5 : Superposition des trois fonds de carte\nLa fonction plot du package sf permet de superposer des couches cartographiques avec l’instruction add=TRUE. Elle permet également de régler les couleurs des polygones (col=) ainsi que la couleur et l’épaisseur des frontières (border= et lwd=). Lorsqu’on ne souhaite pas remplir les polygones on indique col=NULL.\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry, col= \"lightyellow\", border = \"gray80\", lwd=0.5)\nplot(map_arr$geometry, col= NA, border = \"gray50\", lwd=1, add=TRUE)\nplot(map_com$geometry, col= NA, border = \"gray30\", lwd=2, add=TRUE)"
  },
  {
    "objectID": "01-Data.html#logement-social-2020",
    "href": "01-Data.html#logement-social-2020",
    "title": "Préparation des données",
    "section": "Logement social 2020",
    "text": "Logement social 2020\nLes données sur le logement social sont été téléchargées sur le site du ministère du développement durable :\n\nEtape 1 : Chargement du fichier\nOn charge le fichier qui comporte 182735 observation et 70 variables et on le sauvegarde\n\n\nCode\nrpls&lt;-read.csv(\"data/rpls_13055.csv\")\nhead(rpls)\n\n\n  X.1 DROIT DEPCOM CODEPOSTAL                      LIBCOM NUMVOIE INDREP\n1   1     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n2   2     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n3   3     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n4   4     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n5   5     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n6   6     1  13055      13009 Marseille 9e Arrondissement    &lt;NA&gt;   &lt;NA&gt;\n  TYPVOIE                      NOMVOIE NUMAPPT NUMBOITE  ESC COULOIR ETAGE\n1    &lt;NA&gt; 55, Traverse de la Gouffonne     103       NA &lt;NA&gt;    &lt;NA&gt;     0\n2    &lt;NA&gt; 55, Traverse de la Gouffonne     113       NA &lt;NA&gt;    &lt;NA&gt;     1\n3    &lt;NA&gt; 55, Traverse de la Gouffonne     114       NA &lt;NA&gt;    &lt;NA&gt;     1\n4    &lt;NA&gt; 55, Traverse de la Gouffonne     202       NA &lt;NA&gt;    &lt;NA&gt;     0\n5    &lt;NA&gt; 55, Traverse de la Gouffonne     123       NA &lt;NA&gt;    &lt;NA&gt;     2\n6    &lt;NA&gt; 55, Traverse de la Gouffonne     124       NA &lt;NA&gt;    &lt;NA&gt;     2\n  COMPLIDENT ENTREE  BAT     IMMEU                COMPLGEO LIEUDIT QPV\n1       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-1 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n2       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-1 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n3       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-1 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n4       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-2 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n5       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-1 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n6       &lt;NA&gt;   &lt;NA&gt; &lt;NA&gt; 184-BT1-1 RESIDENCE LE MASSALIA I    &lt;NA&gt;   2\n  TYPECONST NBPIECE SURFHAB CONSTRUCT LOCAT PATRIMOINE ORIGINE FINAN FINANAUTRE\n1         C       3      65      1995  1998       1998       1    12         12\n2         C       3      65      1995  1998       1998       1    12         12\n3         C       5     100      1995  1998       1998       1    12         12\n4         C       3      65      1995  1998       1998       1    12         12\n5         C       3      69      1995  1998       1998       1    12         12\n6         C       3      69      1995  1998       1998       1    12         12\n  CONV                    NUMCONV DATCONV NEWLOGT CUS DPEDATE DPEENERGIE\n1    1 13204199785123110750722399      NA      NA  NA      NA          B\n2    1 13204199785123110750722399      NA      NA  NA      NA          B\n3    1 13204199785123110750722399      NA      NA  NA      NA          B\n4    1 13204199785123110750722399      NA      NA  NA      NA          B\n5    1 13204199785123110750722399      NA      NA  NA      NA          B\n6    1 13204199785123110750722399      NA      NA  NA      NA          B\n  DPESERRE SRU_EXPIR SRU_ALINEA CODSEGPATRIM             LIBSEGPATRIM PMR REG\n1        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n2        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n3        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n4        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n5        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n6        C      2031         NA       SEG001 Marseille Prov. Metropol   1  93\n                      LIBREG DEP           LIBDEP      EPCI\n1 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n2 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n3 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n4 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n5 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n6 Provence-Alpes-Côte d'Azur  13 Bouches-du-Rhône 200054807\n                             LIBEPCI EPSG        X       Y PLG_QP PLG_IRIS2021\n1 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n2 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n3 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n4 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n5 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n6 Métropole d'Aix-Marseille-Provence 2154 895698.9 6241946     HZ          404\n  PLG_ZUS PLG_ZFU PLG_QVA PLG_CODE_COMMUNE2021 QUALITE_VOIE QUALITE_NUMERO\n1      HZ     CSZ      HZ                13209           NA             NA\n2      HZ     CSZ      HZ                13209           NA             NA\n3      HZ     CSZ      HZ                13209           NA             NA\n4      HZ     CSZ      HZ                13209           NA             NA\n5      HZ     CSZ      HZ                13209           NA             NA\n6      HZ     CSZ      HZ                13209           NA             NA\n  QUALITE_XY DISTANCE_PRECISION QUALITE_QP QUALITE_IRIS QUALITE_ZUS QUALITE_ZFU\n1         11               &lt;NA&gt;          1            1           1          NA\n2         11               &lt;NA&gt;          1            1           1          NA\n3         11               &lt;NA&gt;          1            1           1          NA\n4         11               &lt;NA&gt;          1            1           1          NA\n5         11               &lt;NA&gt;          1            1           1          NA\n6         11               &lt;NA&gt;          1            1           1          NA\n  QUALITE_QVA COMAQP COMRIL\n1           1      1      1\n2           1      1      1\n3           1      1      1\n4           1      1      1\n5           1      1      1\n6           1      1      1\n\n\nCode\nsaveRDS(rpls,\"res/rpls.RDS\")\n\n\n\n\nEtape 2 : Test de superposition géométrique\nLe fichier comporte deux colonnes X et Y dont on ignore la projection. On va tester leur superposition sur les fonds de carte précédents pour voir s’il s’agit de la même.\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry, col= \"lightyellow\", border = \"gray80\", lwd=0.5)\nplot(map_arr$geometry, col= NA, border = \"gray50\", lwd=1, add=TRUE)\nplot(map_com$geometry, col= NA, border = \"gray30\", lwd=2, add=TRUE)\npoints(rpls$X, rpls$Y, col=\"red\",pch=20, cex=0.2)\n\n\n\n\n\nBingo, la superposition est parfaite donc la projection est la même. Il s’agit de la Lambert93 dont le CRS peut-être affiché par la commande st_crs() du package sf :\n\n\nCode\nst_crs(map_iris)\n\n\nCoordinate Reference System:\n  User input: RGF93 Lambert 93 \n  wkt:\nPROJCRS[\"RGF93 Lambert 93\",\n    BASEGEOGCRS[\"RGF93 geographiques (dms)\",\n        DATUM[\"Reseau Geodesique Francais 1993 v1\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"IGNF\",\"RGF93G\"]],\n    CONVERSION[\"LAMBERT-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"NATIONALE A CARACTERE LEGAL\"],\n        AREA[\"FRANCE METROPOLITAINE (CORSE COMPRISE)\"],\n        BBOX[41,-5.5,52,10]],\n    ID[\"IGNF\",\"LAMB93\"]]\n\n\n\n\nEtape 3 : Carte des logements sociaux\nOn va alors pouvoir créer un fonds de carte géométrique de ces logements sociaux en indiquant la projection du fonds de carte des Iris.\n\n\nCode\n# Transformation du data.frame en objet sf\nrpls_geom&lt;-st_as_sf(rpls,coords = c(\"X\",\"Y\"))\n\n# Récupération du code EPSG de la projection\nst_crs(rpls_geom)&lt;-st_crs(map_iris)\n\n# Sauvegarde au format .RDS\nsaveRDS(rpls_geom, \"res/rpls_geom.RDS\")"
  },
  {
    "objectID": "01-Data.html#bilan",
    "href": "01-Data.html#bilan",
    "title": "Préparation des données",
    "section": "Bilan",
    "text": "Bilan\nNous avons désormais un dossier res qui comporte tous les éléments utiles pour l’analyse de notre zone d’étude.\n\nLe recensement des logements ordinaires en 2020 et ses métadonnées\nLes fonds de carte par iris, arrondissement et commune.\nLe fichier du RPLS pour l’année 2020 en version statistique ou cartographique\n\n\n\nCode\nlist.files(\"res\")\n\n\n[1] \"logt_adr.RDS\"     \"map_arr.RDS\"      \"map_com.RDS\"      \"map_iris_hlm.RDS\"\n[5] \"map_iris.RDS\"     \"rpls_geom.RDS\"    \"rpls.RDS\"         \"tabmen_meta.RDS\" \n[9] \"tabmen.RDS\""
  },
  {
    "objectID": "03-agregation-spatiale.html",
    "href": "03-agregation-spatiale.html",
    "title": "Agrégation spatiale",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      message = FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\n# Packages d'enquête\n#library(xtable)\n#library(survey)\nlibrary(questionr)"
  },
  {
    "objectID": "03-agregation-spatiale.html#objectifs",
    "href": "03-agregation-spatiale.html#objectifs",
    "title": "Agrégation spatiale",
    "section": "Objectifs",
    "text": "Objectifs\nDans cet exercices on va agréger les données issues du recensement des ménages par IRIS puis effectuer une jointurer avec le fonds de carte des IRIS. S’il existe un niveau intermédiaire entre les arrondissements et la commune (les arrondissements), nous allons également agréger les données et le fonds de carte à ce niveau.\nLa cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets uniques rassemblant à la fois\n\nun tableau de données (l’équivalent du fichier .dbf)\nune géométrie (l’équivalent du fichier .shp)\nune projection (l’équivalent du fichier .prj)\n\nLorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf.\nNous allons suivre les étapes suivantes :\n\nPréparer les données statistiques par IRIS dans un data.frame\nCharger un fonds de carte par IRIS au format sf\nEffectuer une jointure entre les deux fichiers par le code IRIS\nSauvegarder le résultat\nAgréger les données statistiques et géométriques par arrondissement\nSauvegarder le résultat."
  },
  {
    "objectID": "03-agregation-spatiale.html#agrégation-des-ménages-par-iris",
    "href": "03-agregation-spatiale.html#agrégation-des-ménages-par-iris",
    "title": "Agrégation spatiale",
    "section": "Agrégation des ménages par Iris",
    "text": "Agrégation des ménages par Iris\n\nPréparer les données statistiques\nOn importe le fichier des individus :\n\n\nCode\ntab_ind&lt;-readRDS(\"res/tabmen.RDS\")\n\n\n\n\nFALSE   X COMMUNE   ARM      IRIS ACHL\nFALSE 1 1   13055 13201 132010101  B11\nFALSE 2 2   13055 13201 132010101  A12\nFALSE 3 3   13055 13201 132010101  B11\n\n\n\n\nAgréger les données\nOn commence par créer un tableau long croisant les deux variables et leur effectif pondéré :\n\n\nCode\ntab_long&lt;- tab_ind %&gt;%\n           filter(HLML != \"Y\")%&gt;%\n           group_by(IRIS,HLML)%&gt;%\n           summarise(NB=sum(IPONDL))\n\n\n\n\n\n\n\nIRIS\nHLML\nNB\n\n\n\n\n132010101\n1\n25.71\n\n\n132010101\n2\n640.22\n\n\n132010102\n1\n125.14\n\n\n132010102\n2\n1060.17\n\n\n132010103\n1\n74.18\n\n\n\n\n\n\n\nPivoter le tableau\nPuis on fait “pivoter” le tableau pour l’obtenir en format large :\n\n\nCode\ntab_large &lt;- tab_long %&gt;% pivot_wider(id_cols = IRIS, \n                                      names_from = HLML,\n                                      names_prefix = \"HLM_\",\n                                      values_from = NB,\n                                      values_fill = 0)\n\n\n\n\n\n\n\nIRIS\nHLM_1\nHLM_2\n\n\n\n\n132010101\n25.71\n640.22\n\n\n132010102\n125.14\n1060.17\n\n\n132010103\n74.18\n1104.85\n\n\n132010104\n176.46\n1444.42\n\n\n132010201\n35.17\n1147.65\n\n\n\n\n\n\n\nAjouter de nouvelles variables\nOn ajoute de nouvelles variables telles que le nombre total de ménage et le % de ménages en HLM :\n\n\nCode\ntab&lt;- tab_large %&gt;% mutate(TOT = HLM_1+HLM_2,\n                           HLM_pct = 100*HLM_1/TOT)\n\n\n\n\n\n\n\nIRIS\nHLM_1\nHLM_2\nTOT\nHLM_pct\n\n\n\n\n132010101\n25.71\n640.22\n665.93\n3.86\n\n\n132010102\n125.14\n1060.17\n1185.31\n10.56\n\n\n132010103\n74.18\n1104.85\n1179.02\n6.29\n\n\n132010104\n176.46\n1444.42\n1620.87\n10.89\n\n\n132010201\n35.17\n1147.65\n1182.82\n2.97\n\n\n\n\n\n\n\nExaminer la distribution statistique\nOn examine l’histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par IRIS.\n\n\nCode\np &lt;- ggplot(tab) + aes (x = HLM_pct) +\n                   geom_histogram(breaks = c(0,10,20,30,40,50,\n                                             60,70,80,90, 100)) +\n                   scale_x_continuous(\"% de ménages en HLM\") +\n                   scale_y_continuous(\"Nombre d'IRIS\") +\n                   ggtitle(label = \"Distribution des logements sociaux à Marseille par IRIS\",\n                           subtitle = \"Source : INSEE, RP 2020\")\n\n\n\n\n\n\n\n\n\nCharger les données géométriques\nOn importe le fichier des iris qui est au format sf en ne gardant que les colonnes utiles et en les renommant si besoin\n\n\nCode\nmap_iris &lt;- readRDS(\"res/map_iris.RDS\")\nmap_iris&lt;-map_iris[,c(5, 6,2,3,8)]\nnames(map_iris)&lt;-c(\"IRIS\",\"NOM_IRIS\",\"ARR\",\"NOM_ARR\",\"geometry\")\n\n\n\n\nFALSE [1] \"sf\"         \"data.frame\"\n\n\n\n\n\nIRIS\nNOM_IRIS\nARR\nNOM_ARR\n\n\n\n\n132060301\nBergers\n13206\nMarseille 6e Arrondissement\n\n\n132060602\nVauban-Fénelon\n13206\nMarseille 6e Arrondissement\n\n\n\n\n\n\n\nJointure des données IRIS et du fonds de carte\n\n\nCode\nmap_iris_tab&lt;-merge(map_iris,tab,\n                   by.x=\"IRIS\",by.y=\"IRIS\",\n                   all.x=T,all.y=F)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIRIS\nNOM_IRIS\nARR\nNOM_ARR\nHLM_1\nHLM_2\nTOT\nHLM_pct\ngeometry\n\n\n\n\n132010101\nLa Bourse\n13201\nMarseille 1er Arrondissement\n25.71\n640.22\n665.93\n3.86\nMULTIPOLYGON (((892644.6 62…\n\n\n132010102\nThubaneau\n13201\nMarseille 1er Arrondissement\n125.14\n1060.17\n1185.31\n10.56\nMULTIPOLYGON (((893235.8 62…\n\n\n132010103\nColbert-Providence\n13201\nMarseille 1er Arrondissement\n74.18\n1104.85\n1179.02\n6.29\nMULTIPOLYGON (((892650.8 62…\n\n\n\n\n\n\n\nCarte sommaire\nOn fait une carte rapide pour vérifier le résultat\n\n\nCode\nplot(map_iris_tab['HLM_pct'])\n\n\n\n\n\n\n\nSauvegarde du fichier par IRIS\nOn sauvegarde notre fichier au format .RDS de R\n\n\nCode\nsaveRDS(map_iris_tab,\"res/map_iris_hlm.RDS\")"
  },
  {
    "objectID": "03-agregation-spatiale.html#agrégation-des-iris-par-arrondissement",
    "href": "03-agregation-spatiale.html#agrégation-des-iris-par-arrondissement",
    "title": "Agrégation spatiale",
    "section": "Agrégation des iris par arrondissement",
    "text": "Agrégation des iris par arrondissement\nGrâce aux nouveaux packages de R (dplyr et sf) il est possible d’agréger simultanément les statistiques et les géométries après les avoir stockés dans un même objet de type “sf”\nDu coup, on peut gagner beaucoup de temps dans les traitements et les analyses cartographiques, en particulier si l’on veut tester différents niveaux d’agrégation.\n\nAgrégation stat + geom\nL’agrégation est très facile et elle concerne à la fois les variables (de stock) et les geometries\n\n\nCode\nmap_arr_tab &lt;- map_iris_tab %&gt;% \n  group_by(ARR, NOM_ARR) %&gt;% \n  summarise(HLM_1=sum(HLM_1,na.rm=T), \n            HLM_2=sum(HLM_2,na.rm=T)) %&gt;%\n  st_cast(\"MULTIPOLYGON\")\n\nmap_arr_tab &lt;- map_arr_tab %&gt;%  mutate(TOT = HLM_1+HLM_2,\n                                  HLM_pct = 100*HLM_1/TOT) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARR\nNOM_ARR\nHLM_1\nHLM_2\nTOT\nHLM_pct\n\n\n\n\n13201\nMarseille 1er Arrondissement\n747.12\n20142.62\n20889.74\n3.58\n\n\n13202\nMarseille 2e Arrondissement\n2203.69\n9951.52\n12155.21\n18.13\n\n\n13203\nMarseille 3e Arrondissement\n4499.22\n17810.20\n22309.43\n20.17\n\n\n\n\n\n\n\nRésultat statistique\nOn examine l’histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par Arrondissement.\n\n\nCode\np &lt;- ggplot(map_arr_tab) + aes (x = HLM_pct) +\n                   geom_histogram(breaks = c(0,10,20,30,40,50,\n                                             60,70,80,90,100)) +\n                   scale_x_continuous(\"% de ménages en HLM\") +\n                   scale_y_continuous(\"Nombre d'arrondissement\") +\n                   ggtitle(label = \"Distribution des logements sociaux à Marseille par arrondissement\",\n                           subtitle = \"Source : INSEE, RP 2020\")\n\n\n\n\n\n\n\n\n\nRésultat cartographique\nOn fait une carte sommaire avec sf\n\n\nCode\nplot(map_arr_tab['HLM_pct'])\n\n\n\n\n\n\n\nSauvegarde du fichier par arrondissements\nOn sauvegarde notre fichier au format .RDS de R\n\n\nCode\nsaveRDS(map_arr_tab,\"data/map_arr_hlm.RDS\")"
  },
  {
    "objectID": "05-exploration.html",
    "href": "05-exploration.html",
    "title": "Exploration",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\n#library(sf,quietly = T, verbose=F)\n\n# Packages d'enquête\n#library(xtable)\n#library(survey)\n#library(questionr)"
  },
  {
    "objectID": "05-exploration.html#préparation-des-données",
    "href": "05-exploration.html#préparation-des-données",
    "title": "Exploration",
    "section": "Préparation des données",
    "text": "Préparation des données\nLe tableau du RPLS demande à être préparé soigneusement avant toute analyse statistique\n\nSélection des variables\nOn décide de sélectionner un nombre limité d’indicateurs dont on veut mesurer la distribution globale pour l’ensemble de la zone d’étude.\n\n\nCode\nrpls&lt;-readRDS(\"res/rpls.RDS\")\n\nsel&lt;-rpls %&gt;% select(nbp = NBPIECE,\n                     sup = SURFHAB,\n                     anc = CONSTRUCT,\n                     ene = DPEENERGIE,\n                     fin = FINAN) \n\n\n\n\nRecodage du type de financement\nOn procède à un recodage du type de financement en quatre catégories correspondant aux différents niveaux de logement social. On décide d’éliminer les cas complexes qui ne rentrent pas dans les quatre catégories\nN.B. Avant de transformer la variable en facteur, on a indiqué un order 1. 2. 3. 4. devant chaque type de financement afin que les graphiques qu nous réaliserons utilise un ordre logique.\n\n\nCode\nsel$fin &lt;- case_when(sel$fin == \"10\" ~ \"1.PLAI\",\n                     sel$fin == \"11\" ~ \"1.PLAI\",\n                     sel$fin == \"12\" ~ \"2.PLUS\",\n                     sel$fin == \"13\" ~ \"2.PLUS\",\n                     sel$fin == \"14\" ~ \"3.PLS\",\n                     sel$fin == \"15\" ~ \"3.PLS\",\n                     sel$fin == \"16\" ~ \"4.PLI\",\n                     sel$fin == \"17\" ~ \"4.PLI\",\n                     sel$fin == \"50\" ~ \"2.PLUS\",\n                     sel$fin == \"51\" ~ \"2.PLUS\",\n                     sel$fin == \"52\" ~ \"2.PLUS\",\n                     sel$fin == \"53\" ~ \"2.PLUS\",\n                     sel$fin == \"54\" ~ \"2.PLUS\",\n                     sel$fin == \"55\" ~ \"2.PLUS\",\n                     .default = NA\n                     )\nsel$fin&lt;-as.factor(sel$fin)\n\n\n\n\nRecodage de la consommation d’énergie\n\n\nCode\nsel$ene&lt;-as.factor(sel$ene)\n\n\n\n\nRésumé rapide\n\n\nCode\nsummary(sel)\n\n\n      nbp             sup              anc            ene            fin       \n Min.   :1.000   Min.   :  9.00   Min.   :1830   D      :27394   1.PLAI: 4885  \n 1st Qu.:3.000   1st Qu.: 51.00   1st Qu.:1961   C      :27239   2.PLUS:60717  \n Median :3.000   Median : 64.00   Median :1971   B      : 6643   3.PLS : 5303  \n Mean   :3.154   Mean   : 63.35   Mean   :1974   A      : 4066   4.PLI : 1826  \n 3rd Qu.:4.000   3rd Qu.: 76.00   3rd Qu.:1992   E      : 3034   NA's  : 9810  \n Max.   :9.000   Max.   :230.00   Max.   :2019   (Other):  370                 \n                                                 NA's   :13795"
  },
  {
    "objectID": "05-exploration.html#analyse-univariée",
    "href": "05-exploration.html#analyse-univariée",
    "title": "Exploration",
    "section": "Analyse univariée",
    "text": "Analyse univariée\nOn décide d’analyser plus précisément les caractéristiques des logements en fonction de leur type de financement. On définit une palette que l’on juge convenable pour représenter les différents types de logement.\n\nType de financement\nOn réalise un tableau de dénombrement :\n\n\nCode\nsel %&gt;% filter(is.na(fin)==FALSE) %&gt;% \n         count(fin) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n     fin     n       pct\n1 1.PLAI  4885  6.716531\n2 2.PLUS 60717 83.481597\n3  3.PLS  5303  7.291251\n4  4.PLI  1826  2.510621\n\n\nOn utilise geom_bar pour créer un diagramme en bâtons. On ajoute une couleur avec un ordre indiquant l’ordre implicite des bénéficiaires du plus social au moins social\n\n\nCode\nmypal&lt;-c(\"red\",\"orange\",\"yellow\",\"lightyellow\")\n\nsel  %&gt;% filter(is.na(fin)==FALSE) %&gt;%\n              ggplot()+\n              aes(x=fin,fill=fin) + \n              geom_bar(stat=\"count\")+\n              scale_fill_manual(values=mypal) +\n              scale_x_discrete(\"Type de logement\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Frequence des types de logements sociaux\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nType énergétique\nOn reprend le programme précédent :\n\n\nCode\nsel %&gt;% filter(is.na(ene)==FALSE) %&gt;% \n         count(ene) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n  ene     n         pct\n1   A  4066  5.91452594\n2   B  6643  9.66310767\n3   C 27239 39.62266896\n4   D 27394 39.84813662\n5   E  3034  4.41334769\n6   F   331  0.48148256\n7   G    39  0.05673057\n\n\nOn réalise un diagramme en bâtons où l’on essaye de retrouver la palette de couleur des classes énergétiques\n\n\nCode\nmypal&lt;-c(\"darkgreen\",\"green4\",\"lightgreen\",\"yellow\",\"orange\",\"red1\",\"brown\")\nsel %&gt;% filter(is.na(ene)==F) %&gt;%\n              ggplot() + \n              aes(x=ene, fill=ene) + \n              geom_bar(stat=\"count\",na.rm = T,) + \n              scale_fill_manual(values=mypal) +\n              scale_x_discrete(\"Classe énergétique du logement\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Classe énergétique des logements sociaux\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nNombre de pièces\nCette variable quantitative discrètre peut être analysée de deux façons différentes. On choisit isic de la traiter comme une variable qualitative :\n\n\nCode\nsel %&gt;% filter(is.na(nbp)==FALSE) %&gt;% \n         count(nbp) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n  nbp     n          pct\n1   1  5400  6.542203269\n2   2 14260 17.276262706\n3   3 32142 38.940647678\n4   4 24371 29.525932567\n5   5  5728  6.939581541\n6   6   584  0.707527168\n7   7    53  0.064210514\n8   8     1  0.001211519\n9   9     2  0.002423038\n\n\nOn transforme en variable catégorielle avant de réaliser le diagramme en bâtons\n\n\nCode\nsel %&gt;% ggplot() + aes(x=as.factor(nbp)) + \n              geom_bar(stat=\"count\") +\n              scale_x_discrete(\"Nombre de pièces\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Taille des logements sociaux (en nombre de pièces)\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nSuperficie habitable\nLà il s’agit d’une véritable variable quantitative continue.\n\n\nCode\nsummary(sel$sup)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   51.00   64.00   63.35   76.00  230.00 \n\n\nOn construit un histogramme puisque la variable est quantitative et continue. On utilise la fonction densité de probabilité pour mieux repérer les pics.\n\n\nCode\nggplot(sel %&gt;% filter(is.na(sup)==F, sup&lt;130))+ \n             aes(x=sup) + \n              geom_histogram(stat = \"density\") +\n              scale_x_continuous(\"Superficie habitable en m2\") +\n              scale_y_continuous(\"Probabilité\") +\n                ggtitle(\"Taille des logements sociaux (en superficie)\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nAncienneté\nOn construit un histogramme puisque la variable est quantitative et continue. On utilise la fonction densité de probabilité pour mieux repérer les pics.\n\n\nCode\nggplot(sel %&gt;% filter(is.na(anc)==F, anc&gt;1900))+ \n             aes(x=anc) + \n              geom_histogram(stat=\"density\")+\n              scale_x_continuous(\"Date de construction des logements\") +\n              scale_y_continuous(\"Probabilité\")"
  },
  {
    "objectID": "05-exploration.html#analyse-bivariée",
    "href": "05-exploration.html#analyse-bivariée",
    "title": "Exploration",
    "section": "Analyse bivariée",
    "text": "Analyse bivariée\nOn donne juste quelques possibilités à titre d’exemple.\n\nX et Y qualitatives\nLes deux variables sont de type qualitatif. On va donc créer un tableau de contingence, analyser les profils puis utiliser un test du chi-2.\n\n\nCode\n# Tableau de contingence\ntab&lt;-table(sel$fin,sel$ene)\nkable(addmargins(tab), caption=\"Tableau de contingence\")\n\n\n\nTableau de contingence\n\n\n\nA\nB\nC\nD\nE\nF\nG\nSum\n\n\n\n\n1.PLAI\n549\n485\n1419\n1372\n297\n32\n13\n4167\n\n\n2.PLUS\n1778\n4155\n22445\n21884\n2150\n262\n15\n52689\n\n\n3.PLS\n700\n554\n898\n684\n107\n3\n5\n2951\n\n\n4.PLI\n311\n675\n363\n121\n63\n9\n0\n1542\n\n\nSum\n3338\n5869\n25125\n24061\n2617\n306\n33\n61349\n\n\n\n\n\nCode\n# Pourcentages en ligne\ntab2&lt;-100*prop.table(addmargins(tab,1),1)\nkable(addmargins(tab2,2), digits=1, caption=\"Profil en ligne\")\n\n\n\nProfil en ligne\n\n\n\nA\nB\nC\nD\nE\nF\nG\nSum\n\n\n\n\n1.PLAI\n13.2\n11.6\n34.1\n32.9\n7.1\n0.8\n0.3\n100\n\n\n2.PLUS\n3.4\n7.9\n42.6\n41.5\n4.1\n0.5\n0.0\n100\n\n\n3.PLS\n23.7\n18.8\n30.4\n23.2\n3.6\n0.1\n0.2\n100\n\n\n4.PLI\n20.2\n43.8\n23.5\n7.8\n4.1\n0.6\n0.0\n100\n\n\nSum\n5.4\n9.6\n41.0\n39.2\n4.3\n0.5\n0.1\n100\n\n\n\n\n\nCode\n# Graphique\nmypal&lt;-c(\"darkgreen\",\"green4\",\"lightgreen\",\"yellow\",\"orange\",\"red1\",\"brown\")\nplot(tab, col=mypal, main = \"Type de logement et isolation énergétique\")\n\n\n\n\n\nCode\n# Test du chi-2\ntest&lt;-chisq.test(tab)\ntest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tab\nX-squared = 6761.3, df = 18, p-value &lt; 2.2e-16\n\n\nLe test du chi2 est incorrect car certaines catégories énergétiques sont trop peu représentées. On procède donc à des regroupements et on applique le même programme.\n\n\nCode\n# Fusion des classes\nsel$ene4&lt;-sel$ene\nlevels(sel$ene4)&lt;-c(\"AB\",\"AB\",\"C\",\"D\",\"EFG\",\"EFG\",\"EFG\")\n\n# Tableau de contingence\ntab&lt;-table(sel$fin,sel$ene4)\nkable(addmargins(tab), caption=\"Tableau de contingence\")\n\n\n\nTableau de contingence\n\n\n\nAB\nC\nD\nEFG\nSum\n\n\n\n\n1.PLAI\n1034\n1419\n1372\n342\n4167\n\n\n2.PLUS\n5933\n22445\n21884\n2427\n52689\n\n\n3.PLS\n1254\n898\n684\n115\n2951\n\n\n4.PLI\n986\n363\n121\n72\n1542\n\n\nSum\n9207\n25125\n24061\n2956\n61349\n\n\n\n\n\nCode\n# Pourcentages en ligne\ntab2&lt;-100*prop.table(addmargins(tab,1),1)\nkable(addmargins(tab2,2), digits=1, caption=\"Profil en ligne\")\n\n\n\nProfil en ligne\n\n\n\nAB\nC\nD\nEFG\nSum\n\n\n\n\n1.PLAI\n24.8\n34.1\n32.9\n8.2\n100\n\n\n2.PLUS\n11.3\n42.6\n41.5\n4.6\n100\n\n\n3.PLS\n42.5\n30.4\n23.2\n3.9\n100\n\n\n4.PLI\n63.9\n23.5\n7.8\n4.7\n100\n\n\nSum\n15.0\n41.0\n39.2\n4.8\n100\n\n\n\n\n\nCode\n# Graphique\n\nmypal&lt;-c(\"darkgreen\",\"lightgreen\",\"yellow\",\"orange\")\nplot(tab, col=mypal, main = \"Type de logement et isolation énergétique\")\n\n\n\n\n\nCode\n# Test du chi-2\ntest&lt;-chisq.test(tab)\ntest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tab\nX-squared = 5787.4, df = 9, p-value &lt; 2.2e-16\n\n\n\n\nY quantitative et X qualitative\nOn va prendre comme exemple la relation entre la surface des logements et leur type de financement. On commence par calculer les paramètres principaux, puis on fait un graphique et enfin on teste l’existence d’une relation.\n\n\nCode\n# Paramètres principaux\ntapply(sel$sup, sel$fin,summary, simplify=T)\n\n\n$`1.PLAI`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  14.00   49.00   65.00   64.01   77.00  190.00 \n\n$`2.PLUS`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   9.00   53.00   65.00   64.57   76.00  230.00 \n\n$`3.PLS`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  15.00   39.00   62.00   55.97   71.00  128.00 \n\n$`4.PLI`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  18.00   53.00   68.00   66.59   77.00  139.00 \n\n\nCode\n# Boxplot\nsel %&gt;% filter(is.na(fin) == F) %&gt;%\n                   ggplot() + aes(y=sup, x=fin) +\n                   geom_boxplot() +\n                   scale_x_discrete(\"Type de logement\") +\n                   scale_y_continuous(\"Superficie habitable\") +\n                   ggtitle(\"Superficie en fonction du type de logement social\",\n                           subtitle = \"Source : RPLS 2020\" )\n\n\n\n\n\nCode\n# Analyse de variance\nmod &lt;- lm(sel$sup~sel$fin)\nsummary(mod)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$fin)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-55.567 -11.567   0.433  12.028 165.433 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    64.0149     0.2502 255.838  &lt; 2e-16 ***\nsel$fin2.PLUS   0.5523     0.2601   2.123   0.0337 *  \nsel$fin3.PLS   -8.0434     0.3468 -23.192  &lt; 2e-16 ***\nsel$fin4.PLI    2.5738     0.4797   5.366  8.1e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.49 on 72727 degrees of freedom\n  (9810 observations deleted due to missingness)\nMultiple R-squared:  0.01651,   Adjusted R-squared:  0.01647 \nF-statistic:   407 on 3 and 72727 DF,  p-value: &lt; 2.2e-16\n\n\nOn effectue un test :\n\n\nCode\nmod&lt;-lm(sel$sup~sel$fin)\nsummary(mod)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$fin)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-55.567 -11.567   0.433  12.028 165.433 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    64.0149     0.2502 255.838  &lt; 2e-16 ***\nsel$fin2.PLUS   0.5523     0.2601   2.123   0.0337 *  \nsel$fin3.PLS   -8.0434     0.3468 -23.192  &lt; 2e-16 ***\nsel$fin4.PLI    2.5738     0.4797   5.366  8.1e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.49 on 72727 degrees of freedom\n  (9810 observations deleted due to missingness)\nMultiple R-squared:  0.01651,   Adjusted R-squared:  0.01647 \nF-statistic:   407 on 3 and 72727 DF,  p-value: &lt; 2.2e-16\n\n\n\n\nSuperficie et ancienneté\nOn calcule le coefficient de corrélation et l’équation de la droite de régression décrivant la relation entre superficie et date de construction.\n\n\nCode\ncor.test(sel$anc, sel$sup)\n\n\n\n    Pearson's product-moment correlation\n\ndata:  sel$anc and sel$sup\nt = 38.063, df = 82539, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.1246279 0.1380366\nsample estimates:\n      cor \n0.1313382 \n\n\nCode\nmod2&lt;-lm(sel$sup~sel$anc)\nsummary(mod2)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$anc)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-53.196 -11.750   0.402  12.610 169.028 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -1.287e+02  5.045e+00  -25.50   &lt;2e-16 ***\nsel$anc      9.724e-02  2.555e-03   38.06   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.92 on 82539 degrees of freedom\nMultiple R-squared:  0.01725,   Adjusted R-squared:  0.01724 \nF-statistic:  1449 on 1 and 82539 DF,  p-value: &lt; 2.2e-16\n\n\nOn réalise un graphique avec ggplot qui reproduit l’ajustement linéaire utilisé :\n\n\nCode\nsel %&gt;% ggplot() +aes(x=anc, y = sup) +\n                  geom_point(size=0.1) +\n                  geom_smooth(method=\"lm\",col=\"red\") +\n                  geom_smooth(col=\"blue\", se=F)+\n                  scale_x_continuous(\"Date de construction\") +\n                  scale_y_continuous(\"Surface habitable\",limits = c(0,150)) +\n                  ggtitle(\"Surface habitable et ancienneté des logements sociaux\") +\n                  theme_light()\n\n\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using method = 'gam' and formula = 'y ~ s(x, bs = \"cs\")'"
  },
  {
    "objectID": "06-agregation_point.html",
    "href": "06-agregation_point.html",
    "title": "Agrégation spatiale",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(tidyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(mapsf)"
  },
  {
    "objectID": "06-agregation_point.html#agrégation-par-iris",
    "href": "06-agregation_point.html#agrégation-par-iris",
    "title": "Agrégation spatiale",
    "section": "Agrégation par IRIS",
    "text": "Agrégation par IRIS\nIl existe deux possibilités :\n\nSoit agréger à l’aide du code IRIS fourni dans la base des logements\nSoit intersecter géométriquement la carte des logements avec celle des IRIS\n\nOn va retenir la première solution qui est plus simple … si les code IRIS sont exacts.\n\nNombre de logements sociaux par IRIS\n\n\nCode\n# Chargement du fichier des IRIS\nmap_iris&lt;-readRDS(\"res/map_iris.RDS\")\n\n# Chargement du fichier des logements\nlogt&lt;-readRDS(\"res/rpls.RDS\")\n\n# Création du code IRIS\nlogt &lt;- logt %&gt;% mutate(CODE_IRIS = as.numeric(paste0(PLG_CODE_COMMUNE2021, \"0\",PLG_IRIS2021)))\n\n# Agrégation\nlogt_iris&lt;-logt %&gt;% st_drop_geometry %&gt;% \n              group_by(CODE_IRIS) %&gt;% \n              summarise(nb = n()) \n\nmap_iris_logt &lt;- left_join(map_iris, logt_iris)\n\n\nJoining with `by = join_by(CODE_IRIS)`\n\n\n\n\nCarte par IRIS\n\n\nCode\nmf_map(map_iris, type=\"base\",col=\"lightyellow\")\nmf_map(map_iris_logt, \n       type=\"prop\",\n       var=\"nb\",\n       col=\"red\",\n       inches=0.05,\n       leg_title = \"nb. de logements\")\n\n\n90 'NA' values are not plotted on the map.\n\n\nCode\nmf_layout(title = \"Distribution des logements sociaux par IRIS\",\n          credits = \"Source : RPLS 2020 et IGN\",\n          frame = TRUE,\n          scale = TRUE)"
  },
  {
    "objectID": "06-agregation_point.html#agrégation-par-adresse",
    "href": "06-agregation_point.html#agrégation-par-adresse",
    "title": "Agrégation spatiale",
    "section": "Agrégation par adresse",
    "text": "Agrégation par adresse\nNous revenons sur le package sf (spatial features) que nous avons déjà rencontré au moment de la création de cartes thématiques par IRIS ou communes à l’aide du package mapsf.\nIci le package sf va être utilisé pour cartographier non pas des zones mais des localisations ponctuelles. Il pourra être à nouveau couplé avec le logiciel de cartogaphie statique comme mapsf , afin par exemple de placer les localisations des logements sociaux au dessus du fonds de carte des IRIS ou communes.\nMais il pourra aussi servir de base à des cartographies dynamiques permettant de placer les points sur des réseaux de rue et plus généralement sur des “tuiles” cartographiques permettant d’effectur des zoom. On utilisera à cet effet d’autres packages comme leaflet ou sa version simplifiée mapview.\n\nChargement des données\nNous chargeons le fichier des logements dans sa version géométrique c’est-à-dire comportant la position géométrique des unités spatiales. Nous le recodons et nous lui ajoutons les coordonnées X et Y des points de localisation.\n\n\nCode\nrpls&lt;-readRDS(\"res/rpls_geom.RDS\")\n\nsel&lt;-rpls %&gt;% select(nbp = NBPIECE,\n                     sup = SURFHAB,\n                     anc = CONSTRUCT,\n                     ene = DPEENERGIE,\n                     fin = FINAN) \n\nsel$fin &lt;- case_when(sel$fin == \"10\" ~ \"1.PLAI\",\n                     sel$fin == \"11\" ~ \"1.PLAI\",\n                     sel$fin == \"12\" ~ \"2.PLUS\",\n                     sel$fin == \"13\" ~ \"2.PLUS\",\n                     sel$fin == \"14\" ~ \"3.PLS\",\n                     sel$fin == \"15\" ~ \"3.PLS\",\n                     sel$fin == \"16\" ~ \"4.PLI\",\n                     sel$fin == \"17\" ~ \"4.PLI\",\n                     sel$fin == \"50\" ~ \"2.PLUS\",\n                     sel$fin == \"51\" ~ \"2.PLUS\",\n                     sel$fin == \"52\" ~ \"2.PLUS\",\n                     sel$fin == \"53\" ~ \"2.PLUS\",\n                     sel$fin == \"54\" ~ \"2.PLUS\",\n                     sel$fin == \"55\" ~ \"2.PLUS\",\n                     .default = \"0.Autre\"\n                     )\n\n\n\ncoo&lt;-st_coordinates(sel)\nsel$X&lt;-coo[,1]\nsel$Y&lt;-coo[,2]\n\n\nsel&lt;-st_drop_geometry(sel)\n\n\n\n\nAgrégation par pseudo-adresse\nOn va considérer que chaque point (X,Y) correspond à une adresse - ce qui n’est pas toujours vrai - et reconstiuer un fichier agrégé par pseudo-adresse. On devrait obtenir ainsi une carte plus précise que la précédente.\n\n\nCode\nmap_adr&lt;-sel %&gt;% st_drop_geometry %&gt;% \n              group_by(X,Y) %&gt;% \n              summarise(nb = n(),\n                        nbp_moy = mean(nbp),\n                        sup_moy = mean(sup),\n                        anc_moy = mean(anc),\n                        ene_min = min(ene),\n                        fin_min = min(fin)) \n\n\n`summarise()` has grouped output by 'X'. You can override using the `.groups`\nargument.\n\n\nCode\nmap_adr&lt;-st_as_sf(map_adr,coords = c(\"X\",\"Y\"))\nst_crs(map_adr)&lt;-2154\nhead(map_adr)\n\n\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 887072.2 ymin: 6254194 xmax: 887107.4 ymax: 6254276\nProjected CRS: RGF93 v1 / Lambert-93\n# A tibble: 6 × 7\n     nb nbp_moy sup_moy anc_moy ene_min fin_min           geometry\n  &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;          &lt;POINT [m]&gt;\n1     1    5       83      1986 E       1.PLAI  (887072.2 6254276)\n2     1    5       91      1986 E       1.PLAI  (887073.2 6254260)\n3     1    6      102      1986 E       1.PLAI  (887074.2 6254243)\n4     1    5       83      1986 E       1.PLAI  (887080.1 6254220)\n5    13    2.69    58.2    1986 E       1.PLAI  (887092.7 6254207)\n6     6    3.5     68.7    1986 E       1.PLAI  (887107.4 6254194)\n\n\n\n\nCarte par adresse\nOn procède à un test rapide de superposition sur la carte communale.\n\n\nCode\nmap_com&lt;-readRDS(\"res/map_com.RDS\")\nmf_map(map_com, type=\"base\",col=\"lightyellow\")\nmf_map(map_adr, \n       type=\"prop\",\n       var=\"nb\",\n       col=\"red\",\n       border = NA,\n       inches=0.05,\n       leg_title = \"nb. de logements\")\nmf_layout(title = \"Distribution des logements sociaux par adresse\",\n          credits = \"Source : RPLS et IGN\",\n          frame = TRUE,\n          scale = TRUE)\n\n\n\n\n\n\n\nSauvegarde\nOn sauvegarde le fonds de carte des données par adresse\n\n\nCode\nsaveRDS(map_adr,file = \"res/logt_adr.RDS\")"
  },
  {
    "objectID": "04-carto-statique.html",
    "href": "04-carto-statique.html",
    "title": "Carto statique",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      message = FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(mapsf,quietly = T, verbose=F)\n\n# Packages d'enquête\n#library(xtable)\n#library(survey)\n#library(questionr)"
  },
  {
    "objectID": "04-carto-statique.html#le-package-map_sf",
    "href": "04-carto-statique.html#le-package-map_sf",
    "title": "Carto statique",
    "section": "Le package map_sf",
    "text": "Le package map_sf\nLe package mapsf permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels de l’UMS RIATE. Il prend la suite du package cartography dont la maintenance demeurera assuré quelque temps encore mais ne fera plus l’objet de développements futurs. Le package mapsf présente l’avantage d’être totalement compatibvle avec le package sf ce qui n’était pas autant le cas pour le package cartography, plus ancien, et créé pour être compatible avec l’ancien package sp.\nOn trouvera la documentation du package mapsf à l’adresse suivante :\nhttps://riatelab.github.io/mapsf/index.html"
  },
  {
    "objectID": "04-carto-statique.html#création-dun-template-cartographique",
    "href": "04-carto-statique.html#création-dun-template-cartographique",
    "title": "Carto statique",
    "section": "Création d’un template cartographique",
    "text": "Création d’un template cartographique\nNous allons dans un premier temps apprendre à créer un fonds de carte vierge mais comportant tout l’habillage nécessaire (“template”). Pour cela nous allons charger différentes couches cartographiques correspondant respectivement aux communes, aux arrondissements et aux iris :\n\n\nCode\nmap_iris&lt;-readRDS(\"res/map_iris.RDS\")\nmap_com &lt;-readRDS(\"res/map_com.RDS\")\nmap_arr &lt;-readRDS(\"res/map_arr.RDS\")\n\nmap_iris_hlm&lt;-readRDS(\"res/map_iris_hlm.RDS\")\n\n\n\ntracé d’un fonds de carte vierge\nLa fonction mf_map() avec le paramètre type = \"base\"permet de tracer une carte vide\n\n\nCode\n mf_map(map_iris, type = \"base\")\n\n\n\n\n\n\n\nSuperposition de couches\nOn peut toutefois ajouter toute une série de paramètres supplémentaire (col=, border=, lwd=, …) et superposer plusieurs fonds de carte avec le paramètre add = TRUE. L’ajout de la fonction layout permet de rajouter un cadre une légende.\n\n\nprogramme\n\n\nCode\n# Trace les Iris avec des paramètres\nmf_map(map_iris,  type = \"base\", \n       col = \"lightyellow\", border=\"gray50\",lwd=0.3)\n# Ajoute les contours des arrondissements\nmf_map(map_arr,  type = \"base\", \n       col = NA,border=\"red\",lwd=0.5,\n       add = TRUE)\n# Ajoute les contours des département\nmf_map(map_com,  type = \"base\", \n       col = NA,border=\"red\",lwd=1,\n       add = TRUE)\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Marseille\", \n          credits = \"Sources : IGN et INSEE\")\n\n\n\n\n\n\n\nAjout d’un thème\nOn peut finalement modifier l’ensemble de la carte en lui ajoutant une instruction mf_theme() qui peut reprendre des styles existants ( “default”, “brutal”, “ink”, “dark”, “agolalight”, “candy”, “darkula”, “iceberg”, “green”, “nevermind”, “jsk”, “barcelona”) mais aussi créer ses propres thèmes\n\n\nprogramme\n\n\nCode\n#Choix du thème\nmf_theme(\"darkula\")\n# Trace les Iris avec des paramètres\nmf_map(map_iris,  type = \"base\",\n       border=\"white\",\n        lwd=0.3)\n# Ajoute les contours des arrondissements\nmf_map(map_arr,  type = \"base\", \n       col = NA, lwd=1,\n       add = TRUE)\n# Ajoute les contours des communes\nmf_map(map_com,  type = \"base\", \n       col = NA, lwd=2,\n       add = TRUE)\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Marseille\", \n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#ajout-de-texte",
    "href": "04-carto-statique.html#ajout-de-texte",
    "title": "Carto statique",
    "section": "Ajout de texte",
    "text": "Ajout de texte\nOn peut ajouter une couche de texte avec la fonction mf_label(). Par exemple, on va ajouter à la carte précédente le code insee des communes\n\nrésultat\n\n\nCode\nmf_theme(\"agolalight\")\n\n# Trace les Iris avec des paramètres\nmf_map(map_iris, \n       type = \"base\", \n       col = \"lightyellow\",\n       border=\"gray80\",\n       lwd=0.3)\n\n# Ajoute les contours des arrondissements\nmf_map(map_arr, \n       type = \"base\", \n       col = NA,\n       border=\"red\",\n       lwd=1,\n       add = TRUE)\n\n# Ajoute les contours des communes\nmf_map(map_com,  type = \"base\", \n       col = NA,border=\"red\",lwd=2,\n       add = TRUE)\n\n# Ajoute les codes des arrondissements\nmap_arr$num&lt;-substr(map_arr$NOM_COM,10,13)\nmf_label(map_arr, \n         var=\"num\",\n         cex=0.7, \n         col=\"blue\",\n         overlap = FALSE)\n\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Arrondissements et Iris de Marseille en 2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-de-stock",
    "href": "04-carto-statique.html#carte-de-stock",
    "title": "Carto statique",
    "section": "Carte de stock",
    "text": "Carte de stock\nUne carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement.\nDans le package mapsf, on réalise ce type de carte à l’aide de la fonction mf_map()en lui donnant le paramètre type=\"prop\".\nOn va tenter à titre d’exemple de représenter la distribution du nombre de ménages ordinaires occupant un logement HLM par IRIS :\n\nCarte de stock minimale\n\n\nCode\n# Trace les contours des communes\nmf_map(x= map_iris, \n       type = \"base\")\n\n# Ajoute le nombre de ménages par IRIS\nmf_map(x =map_iris_hlm, \n      type =\"prop\",\n      var = \"HLM_1\",\n      add=TRUE)\n\n\n\n\n\nMais le résultat est peu satisfaisant car les cercles sont trop grands. Il faut en pratique toujours effectuer un réglage de ceux-ci avec l’instruction inches=\n\n\nCarte de stock habillée\n\n\nCode\nmf_theme(\"agolalight\")\nmf_map(map_iris, type = \"base\",  \n       col = \"lightyellow\",border=\"gray80\", lwd=0.3)\nmf_map(map_arr, type = \"base\", \n       col = NA,border=\"black\",lwd=1,add = TRUE)\n\nmf_map(map_iris_hlm, var = \"HLM_1\",type = \"prop\",\n  inches = 0.05, col = \"red\",leg_pos = \"left\",  \n  leg_title = \"Nombre de ménages\", add=TRUE)\n\nmf_layout(title = \"Distribution des logements HLM en 2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-choroplèthe",
    "href": "04-carto-statique.html#carte-choroplèthe",
    "title": "Carto statique",
    "section": "Carte choroplèthe",
    "text": "Carte choroplèthe\nUne carte choroplèthe ou d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les % de logement HLM des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) et elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes.\nLa fonction du package mapsf adaptée aux variables d’intensité est la fonction mf_map()munie du paramètre type = \"choro\".\nOn va prendre l’exemple de la part des ménages qui résident en HLM\n\nCarte choroplèthe minimale\nSi on ne précise rien, la carte est réalisée à l’aide de la palette par défaut avec un découpage des classes en quantiles (effectifs égaux).\n\n\nprogramme\n\n\nCode\n# Carte choroplèthe\nmf_map(\n  x = map_iris_hlm, \n  var = \"HLM_pct\",\n  type = \"choro\")\n\n\n\n\n\n\n\nCarte choroplèthe habillée\nOn peut arriver à une carte beaucoup plus satisfaisante en contrôlant l’ensemble des paramètres de couleur et de découpage des classes. Puis en superposant les contours de communes au dessus de la carte des IRIS pour faciliter le repérage.\n\n\nprogramme\n\n\nCode\nmybreaks = c(0, 10,20,30,40,50,\n             60,70,80,90, 100)\nmypal &lt;- mf_get_pal(n = 10, \n                    pal = \"Reds\",rev = T)\n# Carte choroplèthe des iris\nmf_map( map_iris_hlm, var = \"HLM_pct\",\n        type = \"choro\",\n        breaks = mybreaks,pal = mypal, \n        border=NA,\n       col_na = \"gray80\",leg_title = \"% HLM\",\n       leg_val_rnd = 0)\n# Contour des arrondissements et cadre\nmf_map(map_arr, type = \"base\", col = NA,\n       border=\"black\",lwd=1,add = TRUE)\nmf_layout(title = \"% de ménages en HLM au RP  2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-stock-choroplèthe-1",
    "href": "04-carto-statique.html#carte-stock-choroplèthe-1",
    "title": "Carto statique",
    "section": "Carte stock + choroplèthe (1)",
    "text": "Carte stock + choroplèthe (1)\nOn peut combiner les deux modes cartographiques par superposition :"
  },
  {
    "objectID": "04-carto-statique.html#carte-stock-choroplèthe",
    "href": "04-carto-statique.html#carte-stock-choroplèthe",
    "title": "Carto statique",
    "section": "Carte stock + choroplèthe",
    "text": "Carte stock + choroplèthe\nMais les cercles dissimuent alors les plages de couleur, aussi on peut utiliser le type prop_choro qui place la variable choroplèthe à l’intérieur des cercles\n\n\nCode\nmf_theme(\"agolalight\")\nmybreaks = c(0, 10,20,30,40,50,60,70,80,90, 100)\nmypal &lt;- mf_get_pal(n = 10, pal = \"Reds\", rev=T)\nmf_map(map_iris_hlm, type = \"base\",  \n       col = \"gray80\",border=\"white\", lwd=0.3)\nmf_map(map_arr, type = \"base\", \n       col = NA,border=\"white\",lwd=1,add = TRUE)\nmf_prop_choro( x = map_iris_hlm,  var = c(\"TOT\", \"HLM_pct\"), \n  inches = 0.06, col_na = \"grey\", pal=mypal,\n  breaks = mybreaks, nbreaks = 4, lwd = 0.1,\n  leg_pos = c(\"right\", \"left\"),leg_val_rnd = c(0,0),\n  leg_title = c(\"nb. ménages\", \"% HLM\"),\n  add = TRUE)\nmf_layout(title = \"Les ménages ordinaires en HLM  2020\", \n          frame = TRUE, credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hackaton 2024",
    "section": "",
    "text": "Développer vos connaissances en analyse quantitative des données dans l’espace\nExploiter des données individuelles (recensement de la population, répertoire logements sociaux)\nApprofondir votre utilisation du logiciel R\nTravailler en groupe et préparer une restitution commune\nRépondre à une “commande” dans un temps limité"
  },
  {
    "objectID": "index.html#objectifs-de-la-semaine",
    "href": "index.html#objectifs-de-la-semaine",
    "title": "Hackaton 2024",
    "section": "",
    "text": "Développer vos connaissances en analyse quantitative des données dans l’espace\nExploiter des données individuelles (recensement de la population, répertoire logements sociaux)\nApprofondir votre utilisation du logiciel R\nTravailler en groupe et préparer une restitution commune\nRépondre à une “commande” dans un temps limité"
  },
  {
    "objectID": "07-carto_dyn.html",
    "href": "07-carto_dyn.html",
    "title": "Cartographie dynamique",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\nknitr::opts_chunk$set(echo = TRUE, \n                      warning= FALSE, \n                      error=FALSE)\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(tidyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\n#library(mapsf)\nlibrary(mapview)\n\n\nThe legacy packages maptools, rgdal, and rgeos, underpinning the sp package,\nwhich was just loaded, will retire in October 2023.\nPlease refer to R-spatial evolution reports for details, especially\nhttps://r-spatial.org/r/2023/05/15/evolution4.html.\nIt may be desirable to make the sf package available;\npackage maintainers should consider adding sf to Suggests:.\nThe sp package is now running under evolution status 2\n     (status 2 uses the sf package in place of rgdal)\n\n\nCode\nlibrary(RColorBrewer)"
  },
  {
    "objectID": "07-carto_dyn.html#objectif",
    "href": "07-carto_dyn.html#objectif",
    "title": "Cartographie dynamique",
    "section": "Objectif",
    "text": "Objectif\n\nStatique ou dynamique ?\n\nCartographie statique\n\nproduction d’images fixes de qualité\nrespect strict des règles de la sémiologie graphique\nchoix libre d’une projection adaptée (e.g. EPSG 2154)\nproduction de documents imprimés à finalité normative ou scientifiques\n\nCartographie dynamique\n\nproduction d’interfaces consultables dans un navigateur.\nmodification possible de l’échelle et de l’arrière-plan\nprojection imposée par les “tuiles” (EPSG 4326)\nproduction de documents interactifs à finalité citoyenne ou exploratoire\n\n\n\n\nPackages R de cartographie dynamique\n\nleaflet : la référence\n\nUne librairie javascript non liée à un langage (R, Python, html, …)\nDisponible dans R sous forme de package\nDéveloppement constant\n\nggmap : l’empire contre attaque\n\ndes outils cartogaphiques utilisant la syntaxe de tidyverse\nimpose désormais un lien avec Google\n\ntmap : une solution hybride\n\npermet de passer facilement du mode statique au mode dynamique\n\nmapview : l’équivalent de mapsf\n\nmis au point par des développeurs allemands\nfacilite l’usage de leaflet\nen progrès constant (mais instable)\n\n\n\n\nPréparation des données\nOn charge les fichiers au format sf et on les transforme en projection WGS94 (EPSG=4326), condition indispensable pour ajouter des “tuiles” dynamiques lors des zoom.\n\n\nCode\nmap_com &lt;- readRDS(\"res/map_com.RDS\") %&gt;%\n              st_transform(4326)\nmap_iris &lt;- readRDS(\"res/map_iris.RDS\") %&gt;%\n              st_transform(4326)\nmap_logt &lt;- readRDS(\"res/logt_adr.RDS\") %&gt;%\n              st_transform(4326)"
  },
  {
    "objectID": "07-carto_dyn.html#cartographie-dynamique",
    "href": "07-carto_dyn.html#cartographie-dynamique",
    "title": "Cartographie dynamique",
    "section": "Cartographie dynamique",
    "text": "Cartographie dynamique\n\nCarte par défaut\nMapview produit par défaut une carte dynamique du fichier sf.\n\n\nCode\nmapview(map_logt)\n\n\n\n\n\n\n\nOn peut zoomer sur la carte, changer les tuiles et faire apparaître des informations sur un point\n\n\nSuperposition de couches\nOn peut créer des couches et les aditionner avec ‘+’ :\n\n\nCode\nm1 = mapview(map_iris, zcol = \"NOM_COM\") \nm2 = mapview(map_logt)\nm1+m2\n\n\n\n\nExemple complet\nOn va essayer de produire une carte plus complexe du nombre et de l’anncienneté des logements sociaux par adresse\n\n\nCode\n# Carte des communes\nmap1 &lt;- mapview(map_com, lwd=1, legend= FALSE,\n                alpha.regions = 0.1)\n# Carte des iris\nmap2 &lt;- mapview(map_iris,lwd = 0.3, label= \"NOM_IRIS\",\n                legend= FALSE, alpha.regions = 0)\n# Carte des logements\nmap3 &lt;- mapview(map_logt,\n                zcol = \"anc_moy\",\n                at = c(1830, 1900,1940, 1970,1980,\n                       1990,2000,2010, 2020),\n                col.regions = brewer.pal(9, \"Spectral\"),\n                cex= \"nb\")\nmap1+map2+map3"
  }
]