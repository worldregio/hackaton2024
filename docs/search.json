[
  {
    "objectID": "02-agregation-sociale.html",
    "href": "02-agregation-sociale.html",
    "title": "Agrégation sociale",
    "section": "",
    "text": "Code\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\n# Packages d'enquête\n#library(xtable)\n#library(survey)\nlibrary(questionr)"
  },
  {
    "objectID": "02-agregation-sociale.html#objectifs",
    "href": "02-agregation-sociale.html#objectifs",
    "title": "Agrégation sociale",
    "section": "Objectifs",
    "text": "Objectifs\nDans ce premier exercice on ne va pas s’intéresser à la géographie des logements sociaux mais à leur sociologie. On va donc croiser la variable Y = ménages résidant dans un logement social avec d’autres variables X1 ..Xn décrivant les attributs des ménages et chercher s’il existe des relations statistiquement significatives.\n\nFormuler des questions ou des hypothèses\nQu’elles soient justes ou fausses, les hypothèses permettent de cadrer l’analyse.\n\nDiplôme et logement social : Les logements sociaux sont-ils réservés aux ménages les moins diplômés ?\nÂge et logement social : Les logements sociaux sont-ils réservés aux jeunes ménages ?\nLogement social, âge et diplômes : Les personnes diplômés quittent-elles les logements sociaux dès que leurs revenus progressent\n\n\n\nOrganiser le travail\nSutout dans le cadre d’un groupe !\n\nNe collecter que les données utiles pour répondre aux questions posées afin de ne pas être tenté de partir dans toutes les directions\nArchiver soigneusement les programmes et les résultats afin de pouvoir reproduire ultérieurement les analyses sur une autre période, un autre territoire\nNe pas attendre d’avoir accumulé tous les résultats pour les commenter car l’analyse peut suggérer des erreurs ou ouvrir de nouvelles pistes.\nPartir des questions et non pas des outils faute de quoi on va trouver des réponses (42 …) sans savoir quelle est la question.\n\n\n\nChargement des données\n\n\nCode\ntab_ind&lt;-readRDS(\"res/tabmen.RDS\")\n\nhead(tab_ind[,1:5],2)\n\n\nFALSE   X COMMUNE   ARM      IRIS ACHL\nFALSE 1 1   13055 13201 132010101  B11\nFALSE 2 2   13055 13201 132010101  A12\n\n\n\n\nRéviser ses cours de statistiques …\nSelon la nature des variables X et Y vous devrez faire appel à des méthodes statistiques différentes. Nous allons donner ici deux exemples différents"
  },
  {
    "objectID": "02-agregation-sociale.html#exemple-1-logement-hlm-et-diplôme",
    "href": "02-agregation-sociale.html#exemple-1-logement-hlm-et-diplôme",
    "title": "Agrégation sociale",
    "section": "Exemple 1 : Logement HLM et diplôme",
    "text": "Exemple 1 : Logement HLM et diplôme\n\nPréparation de l’analyse\n\nSoit la relation entre logement en HLM (Y) et Diplôme le plus élevé du chef de ménage (X). Il s’agit de deux variables catégorielles (= qualitatives) que l’on va typiquement mettre en relation à l’aide d’un tableau de contingence et d’un test du chi-2. L’analyse statistique est simple sous R mais il faut tenir compte de trois difficultés\nLe choix de la population de référence est important. Ici on va sélectionner les ménages dont la personne de référence est âgée de 25-39 ans\nla sélection ou le regroupement des diplômes est également important car cela va influer sur les résultats du test.\nla pondération des individus doit également être prise en compte puisque le recensement est basé sur un sondage\n\n\n\nSélection des individus et des variables\n\n\nCode\ntab_sel&lt;- tab_ind %&gt;% \n  filter(AGEMEN8 == \"25\") %&gt;%\n  select(DIPLM,HLML, IPONDL) \n\n\nknitr::kable(head(tab_sel,4))\n\n\n\n\n\nDIPLM\nHLML\nIPONDL\n\n\n\n\n15\n2\n2.48657\n\n\n15\n2\n2.48657\n\n\n18\n2\n2.48657\n\n\n18\n2\n2.48657\n\n\n\n\n\n\n\nRecodage des modalités\nOn cherche le code des modalités CS1 ezt HLML dans le fichier des métadonnées\n\n\nCode\nmeta&lt;-readRDS(\"res/tabmen_meta.RDS\")\nmetasel &lt;- meta %&gt;% filter(COD_VAR %in% c(\"DIPLM\", \"HLML\"))\nkable(metasel[,c(1,3,4)])\n\n\n\n\n\n\n\n\n\n\nCOD_VAR\nCOD_MOD\nLIB_MOD\n\n\n\n\nDIPLM\n01\nPas de scolarité ou arrêt avant la fin du primaire\n\n\nDIPLM\n02\nAucun diplôme et scolarité interrompue à la fin du primaire ou avant la fin du collège\n\n\nDIPLM\n03\nAucun diplôme et scolarité jusqu’à la fin du collège ou au-delà\n\n\nDIPLM\n11\nCEP (certificat d’études primaires)\n\n\nDIPLM\n12\nBEPC, brevet élémentaire, brevet des collèges, DNB\n\n\nDIPLM\n13\nCAP, BEP ou diplôme de niveau équivalent\n\n\nDIPLM\n14\nBaccalauréat général ou technologique, brevet supérieur, capacité en droit, DAEU, ESEU\n\n\nDIPLM\n15\nBaccalauréat professionnel, brevet professionnel, de technicien ou d’enseignement, diplôme équivalent\n\n\nDIPLM\n16\nBTS, DUT, Deug, Deust, diplôme de la santé ou du social de niveau bac+2, diplôme équivalent\n\n\nDIPLM\n17\nLicence, licence pro, maîtrise, diplôme équivalent de niveau bac+3 ou bac+4\n\n\nDIPLM\n18\nMaster, DEA, DESS, diplôme grande école niveau bac+5, doctorat de santé\n\n\nDIPLM\n19\nDoctorat de recherche (hors santé)\n\n\nDIPLM\nYY\nHors résidence principale\n\n\nHLML\n1\nLogement appartenant à un organisme HLM\n\n\nHLML\n2\nLogement n’appartenant pas à un organisme HLM\n\n\nHLML\nY\nHors résidence principale\n\n\n\n\n\nOn recode les modalités des deux variables en regroupant certaines CSP\n\n\nCode\ntab_sel$HLML&lt;-as.factor(tab_sel$HLML)\nlevels(tab_sel$HLML)&lt;-c(\"HLM-O\",\"HLM-N\",NA)\ntab_sel$DIPLM&lt;-as.factor(tab_sel$DIPLM)\nlevels(tab_sel$DIPLM) &lt;- c(\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\"&lt; BAC\",\n                         \"BAC\",\"BAC\",\n                         \"BAC+123\",\"BAC+123\",\"&gt; BAC+3\",\"&gt; BAC+3\",NA)\ntable(tab_sel$DIPLM)\n\n\nFALSE \nFALSE   &lt; BAC     BAC BAC+123 &gt; BAC+3 \nFALSE   12206    7423   10379    9766\n\n\nCode\nknitr::kable(head(tab_sel,3))\n\n\n\n\n\nDIPLM\nHLML\nIPONDL\n\n\n\n\nBAC\nHLM-N\n2.48657\n\n\nBAC\nHLM-N\n2.48657\n\n\n&gt; BAC+3\nHLM-N\n2.48657\n\n\n\n\n\n\n\nCréation du tableau de contingence non pondéré (FAUX)\nLa solution la plus simple semble être l’instruction table()\n\n\nCode\ntab_cont&lt;-table(tab_sel$HLML,tab_sel$DIPLM)\n\nknitr::kable(addmargins(tab_cont))\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nSum\n\n\n\n\nHLM-O\n3314\n1319\n931\n439\n6003\n\n\nHLM-N\n8892\n6104\n9448\n9327\n33771\n\n\nSum\n12206\n7423\n10379\n9766\n39774\n\n\n\n\n\n\n\nCréation du tableau de contingence pondéré (JUSTE)\nOn pondère avec wtd.table() du package questionr.\n\n\nprogramme\n\n\nCode\nlibrary(questionr)\ntab_cont_wtd&lt;-wtd.table(tab_sel$HLML,tab_sel$DIPLM,\n                        weights = tab_sel$IPONDL)\n\nknitr::kable(round(addmargins(tab_cont_wtd),0))\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nSum\n\n\n\n\nHLM-O\n7538\n2898\n2096\n960\n13492\n\n\nHLM-N\n22318\n14339\n21648\n21557\n79862\n\n\nSum\n29855\n17237\n23744\n22518\n93354\n\n\n\n\n\n\n\nComparaison des résultats en %\n\nTableau non pondéré … légèrement faux !\n\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nAll\n\n\n\n\nHLM-O\n27.2\n17.8\n9\n4.5\n15.1\n\n\nHLM-N\n72.8\n82.2\n91\n95.5\n84.9\n\n\nTotal\n100.0\n100.0\n100\n100.0\n100.0\n\n\n\n\n\n\nTableau pondéré … juste !\n\n\n\n\n\n\n\n&lt; BAC\nBAC\nBAC+123\n&gt; BAC+3\nAll\n\n\n\n\nHLM-O\n25.2\n16.8\n8.8\n4.3\n14.5\n\n\nHLM-N\n74.8\n83.2\n91.2\n95.7\n85.5\n\n\nTotal\n100.0\n100.0\n100.0\n100.0\n100.0\n\n\n\n\n\n\n\nVisualisation du tableau de contingence\nOn choisit l’orientation du tableau et on l’affiche avec plot()\n\n\nCode\nmytable&lt;-wtd.table(tab_sel$DIPLM,tab_sel$HLML,weights = tab_sel$IPONDL)\nplot(mytable)\n\n\n\n\n\nTant qu’à faire, on améliore la figure avec des paramètres supplémentaires :\n\n\nCode\nplot(mytable, \n     main = \"Logements HLM & Diplôme CM\",\n     sub = \"Source : INSEE - RP 2020\",\n     col=c(\"lightyellow\",\"lightgreen\"))\n\n\n\n\n\n\n\nTest du Chi-deux\nCe test se réalise facilement sur le tableau de contingence avec l’instruction chisq.test() :\n\n\nCode\nmytest&lt;-chisq.test(mytable)\nmytest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  mytable\nX-squared = 5389.3, df = 3, p-value &lt; 0.00000000000000022\n\n\nLa lecture de la p-value permet de savoir s’il existe une relation significative entre les deux variables.\n\n\nVisualisation des résidus\nLorsque la relation est significative, on peut visualiser les cases les plus exceptionnelles avec mosaicplot( …, shade = T)"
  },
  {
    "objectID": "02-agregation-sociale.html#exemple-2-hlm-et-ancienneté-doccupation",
    "href": "02-agregation-sociale.html#exemple-2-hlm-et-ancienneté-doccupation",
    "title": "Agrégation sociale",
    "section": "Exemple 2 : HLM et ancienneté d’occupation",
    "text": "Exemple 2 : HLM et ancienneté d’occupation\nDans ce deuxième exemple, on se propose d’analyser si les habitants des HLM y résident depuis plus longtemps que les habitants d’autres types de logements. On va donc calculer leur ancienneté moyenne puis déterminer à l’aide d’un test d’égalité des moyennes s’il y a des différences significatives.\nNous devons comme précédemment tenir compte des pondérations\n\nPréparation des données\n\n\nCode\ntab_sel&lt;- tab_ind  %&gt;%\n  select(ANEM,HLML,IPONDL) %&gt;% \n  filter(ANEM != \"999\") %&gt;%\n  mutate(ANEM = as.numeric(ANEM)) \n\ntab_sel$HLML&lt;-as.factor(tab_sel$HLML)\nlevels(tab_sel$HLML)&lt;-c(\"Oui\",\"Non\")\nhead(tab_sel)\n\n\n  ANEM HLML  IPONDL\n1   11  Non 2.48657\n2   12  Non 2.48657\n3   10  Non 2.48657\n4   81  Non 2.48657\n5   10  Non 2.48657\n6    1  Non 2.48657\n\n\n\n\nStatistiques non pondérées\nOn peut commencer par une description rapide sans pondération :\n\n\nCode\ntapply(tab_sel$ANEM, tab_sel$HLML, summary)\n\n\n$Oui\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   0.00    3.00    8.00   13.73   20.00   88.00 \n\n$Non\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    0.0     2.0     5.0    12.1    18.0   101.0 \n\n\nOn découvre - avec surprise - que l’ancienneté d’occupation des ménages qui résdient en HLM est plus importante que celle des autres ménages. Est-ce une erreur liée à l’absence de pondération ?\n\n\nMoyenne et ecart-types pondérés\nOn calcule la moyenne et l’écart-type pondérés à l’aide du package weights.\n\n\nCode\nlibrary(weights,quietly = T, verbose=F)\ntab_sel %&gt;% group_by(HLML) %&gt;%\n           summarise(moyenne=wtd.mean(ANEM,IPONDL),\n                     variance = wtd.var(ANEM,IPONDL),\n                     ectype = sqrt(variance))\n\n\n# A tibble: 2 × 4\n  HLML  moyenne variance ectype\n  &lt;fct&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;\n1 Oui      15.1     202.   14.2\n2 Non      13.5     228.   15.1\n\n\nLes valeurs sont différentes mais la conclusion demeure la même : les ménages qui résident en HLM y sont depuis plus longtemps que les autres. Toutefois l’écart-type est également tr§s grand ce qui incité à visualiser les distributions.\n\n\nBoxplot\n\n\nCode\nggplot(data = tab_sel)+ aes(x=ANEM, y = HLML) +\n      geom_boxplot() +\n      scale_x_continuous(\"Ancienneté d'occupation (en année)\") +\n      scale_y_discrete(\"Ménages logés en HLM\") +\n      ggtitle(\"Ancienneté d'occupation selon la résdience en HLM à Marseille\",\n              subtitle = \"Source : INSEE RP 2020\") + \n      theme_gray()\n\n\n\n\n\nIl y a effectivement un décalage, aussi bien pour la moyenne, la médiane et les quartiles. Pour conclure on va donc réaliser un test.\n\n\nTest d’égalité des moyennes\n\n\nCode\nt.test(ANEM~HLML, data=tab_sel)\n\n\n\n    Welch Two Sample t-test\n\ndata:  ANEM by HLML\nt = 17.777, df = 41032, p-value &lt; 0.00000000000000022\nalternative hypothesis: true difference in means between group Oui and group Non is not equal to 0\n95 percent confidence interval:\n 1.447961 1.806821\nsample estimates:\nmean in group Oui mean in group Non \n         13.72549          12.09810 \n\n\nOn peut conclure cette fois-ci sans risque d’erreur (p &lt; 0.001) que les habitants des HLM y résident depuis plus longtemps que ceux des autres logements à Marseille en 2020."
  },
  {
    "objectID": "08-semis-de-points.html",
    "href": "08-semis-de-points.html",
    "title": "Ellipse de dispersion",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(mapsf)\nlibrary(leaflet)\n\n# packages de statistique\nlibrary(DescTools)\n\n\nWarning: package 'DescTools' was built under R version 4.3.3\n\n\nCode\nlibrary(car)\n\n\nLoading required package: carData\n\n\n\nAttaching package: 'car'\n\n\nThe following object is masked from 'package:DescTools':\n\n    Recode\n\n\nThe following object is masked from 'package:dplyr':\n\n    recode\n\n\nCode\nlibrary(Hmisc)\n\n\n\nAttaching package: 'Hmisc'\n\n\nThe following objects are masked from 'package:DescTools':\n\n    %nin%, Label, Mean, Quantile\n\n\nThe following objects are masked from 'package:dplyr':\n\n    src, summarize\n\n\nThe following objects are masked from 'package:base':\n\n    format.pval, units"
  },
  {
    "objectID": "08-semis-de-points.html#introduction",
    "href": "08-semis-de-points.html#introduction",
    "title": "Ellipse de dispersion",
    "section": "Introduction",
    "text": "Introduction\nIl est difficile de résumer ici l’ensemble des méthodes d’analyse de semis de points qui constituent une branche très importante de l’analyse spatiale en géographie et de l’épidémiologie en médecine. On se limitera donc ici à quelques applications simples des ellipses de dispersion pour l’étude du logement social et on envoie les étudiants intéressés à deux sites internets plus complets qui présentent les aspects théoriques et indiquent les programmes R permettant d’appliquer sur des cas concrets.\n\nGuerois M., Traore S., 2023, Introduction à l’analyse des semis de points, Ecole d’été CIST 2023, Ouidah, Bénin.\nApparicio P., 2024, Méthodes de répartition ponctuelle, Méthodes d’analyse spatiale : un grand bol d’R"
  },
  {
    "objectID": "08-semis-de-points.html#exemple-théorique",
    "href": "08-semis-de-points.html#exemple-théorique",
    "title": "Ellipse de dispersion",
    "section": "Exemple théorique",
    "text": "Exemple théorique\n\nDistribution aléatoire\nConsidérons tout d’abord un cas théorique de création d’une distribution gaussienne à deux dimensions de paramètres X(moy=10 ect = 4) et Y(moy=5, ect=2). On génère la distribution par tirage au sort de 100 points (xi,yi) à l’aide des paramètres fixés. Il suffit pour cela d’utiliser la fonction rnorm()de R-Base\n\n\nCode\nX&lt;-rnorm(100, mean=10, sd=4)\nY&lt;-rnorm(100, mean=5, sd=2)\nplot(x=X,y=Y,asp = 1, pch=20,col=\"red\", xlim=c(0,20) ,ylim= c(0,10))\n\n\n\n\n\nSi l’on veut résumer cette distribution, on doit retrouver les paramètres caractéristiques qui ont servi à la générer et que, dans le cas présent, nous connaissons.\n\n\nPoint moyen\nLes points ayant tous le même poids dans notre exemple, la détermination du point moyen G, aussi appelé centre de gravité est très simple et consiste simplement à calculer les moyennes de X et Y :\n\n\nCode\nXg &lt;- mean(X)\nYg &lt;- mean(Y)\nG &lt;- cbind(Xg,Yg)\nG\n\n\n           Xg       Yg\n[1,] 10.23571 4.786801\n\n\nOn en retrouve pas exactement les paramètres que nous avions fixé, ce qui est logique puisque nous avons procédé à un tirage aléatoire. Le résulat est tout de même très proche et peut être visualisé.\n\n\nCode\nX&lt;-rnorm(100, mean=10, sd=4)\nY&lt;-rnorm(100, mean=5, sd=2)\nplot(x=X,y=Y,asp = 1, pch=20,col=\"red\", xlim=c(0,20) ,ylim= c(0,10))\npoints(G, col=\"blue\", cex=2, pch=15)\n\n\n\n\n\n\n\nDistance-type\nLa distance-type est une mesure de dispersion des points autour du centre de gravité. C’est l’équivalent de l’écart-type dans un espace à deux dimensions. Sa formule de calcul est basée sur l’écart-type de X et celui de Y :\n\\(D = \\sqrt{\\sigma_X^2+\\sigma_Y^2}\\)\nDans notre exemple, le calcul donne le résultat suivant :\n\n\nCode\nectX = sd(X)\npaste(\"écart-type de X =\", round(ectX,2))\n\n\n[1] \"écart-type de X = 3.8\"\n\n\nCode\nectY = sd(Y)\npaste(\"écart-type de Y =\", round(ectY,2))\n\n\n[1] \"écart-type de Y = 2.15\"\n\n\nCode\nD = sqrt(ectX**2+ectY**2)\npaste(\"Distance-type =\", round(D,2))\n\n\n[1] \"Distance-type = 4.37\"\n\n\nOn peut visualiser la distance-type en traçant un cercle autour du centre de gravite de rayon D. Conformément aux propriétés de l’écart-type, on s’attend à y trouver environ 67% des valeurs. On utilise le package DescTools\n\n\nCode\n#library(DescTools)\n\nX&lt;-rnorm(100, mean=10, sd=4)\nY&lt;-rnorm(100, mean=5, sd=2)\nplot(x=X,y=Y,asp = 1, pch=20,col=\"red\", xlim=c(0,20) ,ylim= c(0,10))\npoints(G, col=\"blue\", cex=2, pch=15)\n\nDrawCircle(x=Xg,y=Yg, \n        r.out=D, \n        col = NA,\n        border = \"blue\",\n        lwd=2)\n\n\n\n\n\n\n\nEllipse de dispersion\nNous avons toutefois observé que la dispersion du semis de point créé était deux fois plus forte le long de l’axe X que de l’axe Y. Il n’est donc pas logique de résumer ce semis de point par un cercle et il serait plus adapté de lui donner la forme d’une ellipse dont l’axe horizontal serait proportionnel à l’écart-type de X et l’axe vertical à l’écart-type de Y. Ce qui donnerait la représentation suivante :\n\n\nCode\n#library(DescTools)\nX&lt;-rnorm(100, mean=10, sd=4)\nY&lt;-rnorm(100, mean=5, sd=2)\nplot(x=X,y=Y,asp = 1, pch=20,col=\"red\", xlim=c(0,20) ,ylim= c(0,10))\npoints(G, col=\"blue\", cex=2, pch=15)\nDrawEllipse(x=Xg, \n            y=Yg, \n            radius.x=ectX, \n            radius.y=ectY, \n            col = NA,\n            border = \"blue\",\n            lwd=2)\n\n\n\n\n\nCette fois-ci l’ellipse s’ajuste beaucoup mieux au nuage de point et permet d’en fournir un résumé pertinent qui correspond bien à deux tiers de l’effectif.\n\n\nIntervalles de confiance\nOn arrive donc à une solution générale qui consiste à chercher une ellipse théorique qui regroupera un certain pourcentage des points dans l’hypothèse d’une distribution gaussienne à deux dimensions. Les axes de l’ellipse ne seront pas forcément orthogonaux et pourront s’incliner si l’allongement est en diagonale.\nOn va ici utiliser la fonction dataEllipse() du package car qui fournit le graphique en une seule ligne de commande :\n\n\nCode\n#library(car)\ndataEllipse(X,Y)\n\n\n\n\n\nOn peut améliorer considérablement la figure en lui ajoutant des paramètres graphiques et un habillage. La fonction dataEllipse propose de nombreux paramètres qui permettent de choisir le nombre d’ellipses, la probabilité associée, les couleurs, etc.\n\n\nCode\ndataEllipse(x=X,\n            y=Y,\n            pch=20,\n            levels = c(0.67,0.95),\n            ellipse.label = c(\"1 ect. = 67%\",\"2 ect. = 95%\"),\n            col=c(\"red\",\"blue\"),\n            fill= TRUE,\n            fill.alpha = 0.2)"
  },
  {
    "objectID": "08-semis-de-points.html#semis-non-pondéré-rpls",
    "href": "08-semis-de-points.html#semis-non-pondéré-rpls",
    "title": "Ellipse de dispersion",
    "section": "Semis non pondéré (RPLS)",
    "text": "Semis non pondéré (RPLS)\nEssayons d’appliquer la méthode précédente au cas d’un semis de point non pondéré, celui des logements de la base RPLS.\n\nDonnées\nOn charge le fichier original où chaque logement correspond à une ligne. Il y a évidemment des superpositions de logement au même emplacement mais cela n’est pas un souci et le semis est actuellement non pondéré.\nLa seule chose que nous ayons à faire consiste donc à extraire les coordonnées X,Y des logements sociaux dans une projection cartographique permettant de calculer des distances approximatives à vol d’oiseau. On va donc bien vérifier que la projection est de type Lambert93 (EPSG = 2154) puis utiliser la fonction fonction st_coordinates() pour récupérer les positions X et Y de chaque logement.\n\n\nCode\nlogt&lt;-readRDS(file = \"res/rpls_geom.RDS\")\n#st_crs(logt)\ncoo&lt;-st_coordinates(logt)\nlogt$X&lt;-coo[,1]\nlogt$Y&lt;-coo[,2]\n\n\n\n\nCentre de gravité\nOn calcule la postion du centre de gravité de l’ensemble des logements sociaux en reprenant le programme précédent\n\n\nCode\nXg&lt;-mean(logt$X)\nYg&lt;-mean(logt$Y)\nG&lt;-cbind(Xg,Yg)\nG\n\n\n           Xg      Yg\n[1,] 894636.2 6249016\n\n\nEnsuite on visualise sa position sur une carte. On ajoute les contours de la commune (et des arrondissements) pour mieux se repérer.\n\n\nCode\nmap&lt;-readRDS(\"res/map_com.RDS\")\nmap_arr&lt;-readRDS(\"res/map_arr.RDS\")\nst_crs(map)\n\n\nCoordinate Reference System:\n  User input: RGF93 Lambert 93 \n  wkt:\nPROJCRS[\"RGF93 Lambert 93\",\n    BASEGEOGCRS[\"RGF93 geographiques (dms)\",\n        DATUM[\"Reseau Geodesique Francais 1993 v1\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"IGNF\",\"RGF93G\"]],\n    CONVERSION[\"LAMBERT-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"NATIONALE A CARACTERE LEGAL\"],\n        AREA[\"FRANCE METROPOLITAINE (CORSE COMPRISE)\"],\n        BBOX[41,-5.5,52,10]],\n    ID[\"IGNF\",\"LAMB93\"]]\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map$geometry, col=\"lightyellow\")\nplot(map_arr$geometry, col=NA, border=\"gray30\", lwd=0.5, add=T)\npoints(cbind(logt$X, logt$Y), col=\"red\", pch=20, cex=0.1)\npoints(G, col=\"blue\",pch=15, cex=1)\n\n\n\n\n\nSi on veut connaître la localisation exacte de ce point, on peut le projeter en EPSG4326 et le visualiser avec leaflet (Cf. cours précédent).\n\n\nCode\n# Rassemble les coordonnées\nG&lt;-as.data.frame(G)\n\n# Transforme en fichier sf\ncentre &lt;- st_as_sf(G,coords=c(1,2))\nst_crs(centre)&lt;-2154\n\n# Projette en latitude longitude\ncentre&lt;-st_transform(centre, 4326)\n\n\n# Visualise le point\nmap &lt;- leaflet(centre) %&gt;% \n            addTiles() %&gt;%\n            addMarkers()\nmap\n\n\n\n\n\n\nOn voit qu’il se situe Boulevard Velten, à proximité du couvent des Petites Soeurs des Pauvres … Tout un symbôle ! En tous les cas cet emplacement pourrait être utilisé pour localiser l’office central des logements sociaux même s’il ne correspond pas tout à fait exactement au point le plus accessible (Cf. cours sur point moyen et point médian)\n-QUESTIONS :  Le centre de gravité est-il le même pour tous les types de logements sociaux (PLAI, PLUS,…) ? S’est-il déplacé au cours du temps ? etc.\n\n\nDistance-type\nOn calcule sans difficultés la distance-type des logements sociaux à ce centre de gravité à l’aide des deux écarts-types :\n\n\nCode\nectX = sd(logt$X)\npaste(\"écart-type de X =\", round(ectX,2))\n\n\n[1] \"écart-type de X = 2718.79\"\n\n\nCode\nectY = sd(logt$Y)\npaste(\"écart-type de Y =\", round(ectY,2))\n\n\n[1] \"écart-type de Y = 3695.06\"\n\n\nCode\nD = sqrt(ectX**2+ectY**2)\npaste(\"Distance-type =\", round(D,2))\n\n\n[1] \"Distance-type = 4587.51\"\n\n\nLes résultats sont exprimés en mètres et on peut donc estimer que la dispersion des logements sociaux par rapport à leur centre de gravité est d’environ 4.5 km.\n-QUESTIONS :  La dispersion est-elle le même pour tous les types de logements sociaux (PLAI, PLUS,…) ? A-t-elle augmenté ou diminué au cours du temps ? etc.\n\n\nEllipse de dispersion\nOn peut très facilement tracer une ellipse de dispersion sur une carte statique produite à l’aide de mapsf. Il suffit en effet d’ajouter l’instruction add=T dans la fonction Dataellipse() du package car.\n\n\nCode\nmap&lt;-readRDS(\"res/map_com.RDS\")\nmap_arr&lt;-readRDS(\"res/map_arr.RDS\")\n\n\nmf_map(map, type=\"base\",col=\"lightyellow\")\nmf_map(map_arr, type = \"base\", col= NA, border=\"gray30\", add=T)\ndataEllipse(x=logt$X,\n            y=logt$Y,\n            pch=20,\n            cex=0.1,\n            levels = c(0.25,0.5, 0.75),\n            ellipse.label = c(\"25%\",\"50%\",\"75%\"),\n            col=c(\"red\",\"blue\"),\n            fill= TRUE,\n            add=T)\nmf_layout(title = \"Ellipses de dispersion des logements sociaux aux seuils 25%, 50% et 75%\",\n          credits = \"Source : RPLS & IGN\",\n          scale = T,\n          frame= T\n          )\n\n\n\n\n\nIl est possible d’introduire dans la fonction DataEllipse une variable catégorielle pour tracer plusieurs ellipse. On peut ainsi par exemple tracer trois ellipses correspondant aux logements construits avant 1944, de 1944 à 1974 et après 1974.\n\n\nCode\nlogt$periode&lt;-cut(logt$CONSTRUCT, breaks=c(1800, 1944, 1974, 2020))\nlevels(logt$periode) &lt;-c(\"1944&lt;\",\"1944-74\",\"&gt;1974\")\ntable(logt$periode)\n\n\n\n  1944&lt; 1944-74   &gt;1974 \n   4572   42326   25874 \n\n\nCode\nmf_map(map, type=\"base\",col=\"gray90\")\nmf_map(map_arr, type = \"base\", col= NA, border=\"gray30\", add=T)\nmf_map(logt, type=\"typo\",\n       var=\"periode\",\n       pch=20,\n       cex=0.3,\n       pal=c(\"brown\",\"red\",\"blue\"),\n       add=T)\ndataEllipse(x=logt$X,\n            y=logt$Y,\n            groups = logt$periode,\n            plot.points = FALSE,\n            pch=20,\n            cex=0.1,\n            levels = 0.5,\n            col=c(\"brown\",\"red\",\"blue\"),\n            fill= TRUE,\n            fill.alpha = 0.1,\n            add=TRUE)\nmf_layout(title = \"Evolution temporelle des ellipses de dispersion des logements sociaux au seuil de 50%\",\n          credits = \"Source : RPLS & IGN\",\n          scale = T,\n          frame= T\n          )\n\n\n\n\n\n-QUESTIONS :  Les ellipses de dispersion sont-elles les mêmes pour tous les types de logements ? Comment évoluent-elles au cours du temps ?"
  },
  {
    "objectID": "08-semis-de-points.html#semis-pondérés-rp",
    "href": "08-semis-de-points.html#semis-pondérés-rp",
    "title": "Ellipse de dispersion",
    "section": "Semis pondérés (RP)",
    "text": "Semis pondérés (RP)\nOn peut appliquer les mêmes méthodes au cas de semis de point pondérés. On aurait donc pu utiliser le fichier des logements sociaux regroupés par adresse pour obtenir des visualisations plus juste des points superposés dans l’analyse précédente.\nNous allons ici prendre l’exemple des données par IRIS pour lesquelles on ne connaît pas la localisation exacte des habitants et tenter de mesurer les paramètres respectifs de dispersion de l’ensemble de la population de Marseille puis de la population qui réside en HLM.\n\nDonnées\nOn charge le fichier des données sur les ménages en HLM par IRIS que nous avons créé précédemment. Nous en extrayons les centroïdes pour obtenir des coordonnées X et Y à l’aide des deux fonctions st_coodinates() et st_centroid() du package sf\n\n\nCode\nmap_iris_hlm&lt;-readRDS(\"res/map_iris_hlm.RDS\") %&gt;% filter(is.na(TOT)==F)\ncoo&lt;-st_coordinates(st_centroid(map_iris_hlm))\nmap_iris_hlm$X &lt;-coo[,1]\nmap_iris_hlm$Y &lt;-coo[,2]\n\n\n\n\nCentre de gravité\nOn a besoin du package Hmisc pour calculer des moyenne et des écart-types pondérés\n\n\nCode\n#library(Hmisc)\n\n# Ensemble de la population\nXg_tot &lt;- wtd.mean(map_iris_hlm$X, weights = map_iris_hlm$TOT)\nYg_tot &lt;- wtd.mean(map_iris_hlm$Y, weights = map_iris_hlm$TOT)\nG_tot&lt;-cbind(Xg_tot,Yg_tot)\nG_tot\n\n\n       Xg_tot  Yg_tot\n[1,] 894727.4 6247501\n\n\nCode\n# Population vivant en HLM\nXg_hlm &lt;- wtd.mean(map_iris_hlm$X, weights = map_iris_hlm$HLM_1)\nYg_hlm &lt;- wtd.mean(map_iris_hlm$Y, weights = map_iris_hlm$HLM_1)\nG_hlm&lt;-cbind(Xg_hlm,Yg_hlm)\nG_hlm\n\n\n       Xg_hlm  Yg_hlm\n[1,] 894647.9 6248944\n\n\nOn visualise la position des deux points sur une carte :\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris_hlm$geometry, col=\"lightyellow\", lwd=0.1)\npoints(G_tot, col=\"blue\", pch=20)\npoints(G_hlm, col=\"red\", pch=20)\n\n\n\n\n\nLe centre de gravité des HLM est clairement situé plus au nord que celui de tous les logements.\n\n\nDistance-type\n\n\nCode\n#library(Hmisc)\n\n# Ensemble de la population\nVarX_tot &lt;- wtd.var(map_iris_hlm$X, weights = map_iris_hlm$TOT)\nVarY_tot &lt;- wtd.var(map_iris_hlm$Y, weights = map_iris_hlm$TOT)\nD_tot &lt;- sqrt(VarX_tot+VarY_tot)\nD_tot\n\n\n[1] 4304.447\n\n\nCode\n# Population vivant en HLM\nVarX_hlm &lt;- wtd.var(map_iris_hlm$X, weights = map_iris_hlm$HLM_1)\nVarY_hlm &lt;- wtd.var(map_iris_hlm$Y, weights = map_iris_hlm$HLM_1)\nD_hlm &lt;- sqrt(VarX_hlm+VarY_hlm)\nD_hlm\n\n\n[1] 4630.377\n\n\nOn constate que la dispersion des ménages en HLM est légèrement plus forte que celle de la population totale. Les ménages en HLM sont donc a priori situés davantage en périphérie du centre.\n\n\nEllipses de dispersion\nOn peut terminer notre analyse par la réalisation de cartes par ellipses en combinant les packages map_sf et car\n\n\nCode\npar(mfrow=c(1,2))\n\nmf_map(map_iris_hlm, type=\"base\",col=\"lightyellow\")\ndataEllipse(map_iris_hlm$X, \n            map_iris_hlm$Y,\n            weights = map_iris_hlm$TOT, \n            col=\"blue\",\n            fill = T,\n            fill.alpha = 0.2,\n            ellipse.label = c(\"67%\",\"95%\"),\n            pch=20,\n            cex=0.4,\n            levels = c(0.67,0.95),\n            add=T)\nmf_layout(title = \"Ellipses - Tous ménages\",\n          frame=T)\n\nmf_map(map_iris_hlm, type=\"base\",col=\"lightyellow\")\ndataEllipse(map_iris_hlm$X, \n            map_iris_hlm$Y,\n            weights = map_iris_hlm$HLM_1, \n            col=\"red\",\n            fill = T,\n            fill.alpha = 0.2,\n            ellipse.label = c(\"67%\",\"95%\"),\n            pch=20,\n            cex=0.7,\n            levels = c(0.67, 0.95),\n            add=T)\nmf_layout(title = \"Ellipses - Ménages en HLM\",\n          frame=T)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hackaton 2024",
    "section": "",
    "text": "Développer vos connaissances en analyse quantitative des données dans l’espace\nExploiter des données individuelles (recensement de la population, répertoire des logements sociaux)\nApprofondir votre utilisation du logiciel R\nTravailler en groupe et préparer une restitution commune\nRépondre à une “commande” dans un temps limité"
  },
  {
    "objectID": "index.html#objectifs-de-la-semaine",
    "href": "index.html#objectifs-de-la-semaine",
    "title": "Hackaton 2024",
    "section": "",
    "text": "Développer vos connaissances en analyse quantitative des données dans l’espace\nExploiter des données individuelles (recensement de la population, répertoire des logements sociaux)\nApprofondir votre utilisation du logiciel R\nTravailler en groupe et préparer une restitution commune\nRépondre à une “commande” dans un temps limité"
  },
  {
    "objectID": "index.html#organisation-de-la-semaine",
    "href": "index.html#organisation-de-la-semaine",
    "title": "Hackaton 2024",
    "section": "Organisation de la semaine",
    "text": "Organisation de la semaine\n\nPlanning des intervenants et contenu des journées\n\n07/10 : Organisation de la semaine et présentation des données (matin, Pierre Pistre)\n07/10 : Chargement des données et prise en main des données individuelles de recensement (après-midi, Claude Grasland)\n08/10 : Prise en main des données individuelles sur les logements sociaux (matin, Pierre Pistre)\n08/10 : Approfondissements statistiques et cartographiques (semis de points… ; après-midi, Claude Grasland)\n09/10 et 10/10 : Analyses temporelles et accompagnement des projets de groupe (Hadrien Commenges)\n11/10 : Finalisation des projets de groupe en autonomie (matin) et restitution orale (après-midi)\n\n\n\nHoraires des séances et planning des salles (Bâtiment Olympe de Gouges, Campus des Grands Moulins, Université Paris Cité)\n\n07/10 : 9h30-12h30 et 13h30-17h30 : salle M019 (étage Mezzanine)\n08/10 : 9h30-12h30 et 13h30-17h30 : salle 209 (2ième étage)\n09/10 : 9h30-12h30 et 13h30-17h30 : salle 209 (2ième étage)\n10/10 : 9h30-12h30 et 13h30-17h30 : salle 209 (2ième étage)\n11/10 : 9h30-12h30 et 13h30-17h30 : salle 209 (2ième étage)"
  },
  {
    "objectID": "index.html#données-utilisées",
    "href": "index.html#données-utilisées",
    "title": "Hackaton 2024",
    "section": "Données utilisées",
    "text": "Données utilisées\n\n(sources) Base de données principales :\n\n\nFichier “Logements oridinaires” (LOGEMT) 2020 (localisations : IRIS, communes. . . ), produit par l’INSEE à partir du recensement de la population. Données en accés libre : https://www.insee.fr/fr/statistiques/7705908?sommaire=7637890\nRépertoire des logements locatifs des bailleurs sociaux en 2020, produit par le Ministère de la Transition écologique. Données en accès libre : https://www.data.gouv.fr/fr/datasets/repertoire-des-logements-locatifs-des-bailleurs-sociaux/\n\n\n(sources) Autres fichiers :\n\n\nShapefile Contours IRIS® (IGN) : https://geoservices.ign.fr/contoursiris"
  },
  {
    "objectID": "index.html#exercice-dapplication-en-groupe",
    "href": "index.html#exercice-dapplication-en-groupe",
    "title": "Hackaton 2024",
    "section": "Exercice d’application en groupe",
    "text": "Exercice d’application en groupe\n\nPérimètres de l’exercice\n\nCas d’étude : commune-centre d’une grande agglomération française\nObjet d’étude : les logements locatifs sociaux et leurs habitants\nEchelles et mailles géographiques : communes, IRIS, adresses\n\n\n\nConsigne de la “commande”\n\nContexte général légal : la loi relative à la solidarité et au renouvellement urbain (SRU), adoptée le 13 décembre 2000, vise notamment un meilleur équilibre de répartition des logements sociaux en France. Son article 55 oblige “certaines communes à disposer d’un nombre minimum de logements sociaux, proportionnel à leur parc résidentiel” (pour des informations supplémentaires : https://www.ecologie.gouv.fr/larticle-55-loi-solidarite-et-renouvellement-urbain-sru-mode-demploi ; https://www.ecologie.gouv.fr/sru?ville=Mions&code=69283) ; ces communes doivent en particulier “disposer de 25 % de logements sociaux, en regard des résidences principales, d’ici 2025”.\nCommande : si le logement social est surtout un levier de politique publique en matière de logement et d’action sociale, il est aussi un domaine d’analyse important des inégalités sociospatiales. En 2015, France Stratégie (“Institution autonome placée auprès du Premier ministre, qui contribue à l’action publique par ses analyses et ses propositions”) a analysé l’évolution de la ségrégation résidentielle - au sens d’une concentration spatiale plus ou moins forte des populations et des logements selon leurs caractéristiques sociales - dans les principales unités urbaines de France métropolitaine (voir https://www.strategie.gouv.fr/publications/evolution-de-segregation-residentielle-france). Cette étude souligne notamment la stabilité générale de la ségrégation depuis les années 1990 et même une baisse pour le parc HLM, c’est-à-dire une meilleure diffusion des logements sociaux sur le territoire. A la suite de cette étude de référence, l’INSEE décide de commander à ses antennes régionales la réalisation d’études rigoureuses, synthétiques et fines spatialement sur la situation du logement social dans plusieurs communes centrales de grandes agglomérations françaises. Il s’agit principalement d’évaluer la situation de ces communes vis-à-vis du cadre légal de la loi SRU et d’approfondir la connaissance institutionnelle sur la géographie interne de répartition des logements sociaux : la tendance récente est-elle plutôt toujours à une diffusion et à une moindre ségrégation ?… Le format attendu de ces notes de synthèse, mobilisant les données disponibles les plus précises, est celui d’un 4 pages de type Insee Première (https://www.insee.fr/fr/statistiques/3635547)“.\n\n\n\nModalités de l’exercice, restitution du travail et organisation durant la semaine\n\nLundi matin : constitution de groupes de 4 étudiant·es de préférence (ou 5), mélangeant les profils de Master\nLundi à mercredi : réflexion sur les possibilités d’analyse et explorations des données : variables pertinentes, traitements envisagés…\nMardi à jeudi : réalisation des analyses statistiques et cartographiques\nMercredi à vendredi matin : organisation, mise en forme des analyses et rédaction de la note écrite\nVendredi après-midi : présentation orale (environ 10 minutes, sans autre support visuel que la note écrite) devant un “jury” composé des intervenants de la semaine (et de possibles extérieurs)\n\n\n\nCas d’étude\nLa commune-centre de grandes agglomérations françaises :\n\nLyon (codegeo : 69123)\nMontpellier (codegeo : 34172)\nNantes (codegeo : 44109)\nNice (codegeo : 06088)\nRennes (codegeo : 35238)\nSaint-Etienne (codegeo : 42218)\nStrasbourg (codegeo : 67482)\nToulouse (codegeo : 31555)\n\n\n\nFormat du rendu\n\nIntroduction et définition (thématique et statistique) de l’objet : thème et cas d’étude\nEtat des lieux général des logements sociaux dans la commune-centre étudiée, par rapport au contexte national (loi SRU par exemple), aux évolutions temporelles… Echelle de référence = commune ; maille de référence = IRIS\nCaractérisation des logements sociaux (types de logement, habitants) et de leur localisation dans la commune d’étude. Echelle de référence = commune ; mailles de référence = IRIS, adresse.\nApprofondissements selon les catégories de logements sociaux (cf. quatre modes de financement : PLI, PLS, PLAI, PLUS). Echelle de référence = commune ; mailles de référence = IRIS, adresse."
  },
  {
    "objectID": "04-carto-statique.html",
    "href": "04-carto-statique.html",
    "title": "Carto statique",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(mapsf,quietly = T, verbose=F)\n\n# Packages d'enquête\n#library(xtable)\n#library(survey)\n#library(questionr)"
  },
  {
    "objectID": "04-carto-statique.html#le-package-map_sf",
    "href": "04-carto-statique.html#le-package-map_sf",
    "title": "Carto statique",
    "section": "Le package map_sf",
    "text": "Le package map_sf\nLe package mapsf permet de réaliser des cartes statiques de très haute qualité. Il a en effet été mis au point par des cartographes et des géomaticiens professionnels de l’UMS RIATE. Il prend la suite du package cartography dont la maintenance demeurera assuré quelque temps encore mais ne fera plus l’objet de développements futurs. Le package mapsf présente l’avantage d’être totalement compatibvle avec le package sf ce qui n’était pas autant le cas pour le package cartography, plus ancien, et créé pour être compatible avec l’ancien package sp.\nOn trouvera la documentation du package mapsf à l’adresse suivante :\nhttps://riatelab.github.io/mapsf/index.html"
  },
  {
    "objectID": "04-carto-statique.html#création-dun-template-cartographique",
    "href": "04-carto-statique.html#création-dun-template-cartographique",
    "title": "Carto statique",
    "section": "Création d’un template cartographique",
    "text": "Création d’un template cartographique\nNous allons dans un premier temps apprendre à créer un fonds de carte vierge mais comportant tout l’habillage nécessaire (“template”). Pour cela nous allons charger différentes couches cartographiques correspondant respectivement aux communes, aux arrondissements et aux iris :\n\n\nCode\nmap_iris&lt;-readRDS(\"res/map_iris.RDS\")\nmap_com &lt;-readRDS(\"res/map_com.RDS\")\nmap_arr &lt;-readRDS(\"res/map_arr.RDS\")\n\nmap_iris_hlm&lt;-readRDS(\"res/map_iris_hlm.RDS\")\n\n\n\ntracé d’un fonds de carte vierge\nLa fonction mf_map() avec le paramètre type = \"base\"permet de tracer une carte vide\n\n\nCode\n mf_map(map_iris, type = \"base\")\n\n\n\n\n\n\n\nSuperposition de couches\nOn peut toutefois ajouter toute une série de paramètres supplémentaire (col=, border=, lwd=, …) et superposer plusieurs fonds de carte avec le paramètre add = TRUE. L’ajout de la fonction layout permet de rajouter un cadre une légende.\n\n\nprogramme\n\n\nCode\n# Trace les Iris avec des paramètres\nmf_map(map_iris,  type = \"base\", \n       col = \"lightyellow\", border=\"gray50\",lwd=0.3)\n# Ajoute les contours des arrondissements\nmf_map(map_arr,  type = \"base\", \n       col = NA,border=\"red\",lwd=0.5,\n       add = TRUE)\n# Ajoute les contours des département\nmf_map(map_com,  type = \"base\", \n       col = NA,border=\"red\",lwd=1,\n       add = TRUE)\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Marseille\", \n          credits = \"Sources : IGN et INSEE\")\n\n\n\n\n\n\n\nAjout d’un thème\nOn peut finalement modifier l’ensemble de la carte en lui ajoutant une instruction mf_theme() qui peut reprendre des styles existants ( “default”, “brutal”, “ink”, “dark”, “agolalight”, “candy”, “darkula”, “iceberg”, “green”, “nevermind”, “jsk”, “barcelona”) mais aussi créer ses propres thèmes\n\n\nprogramme\n\n\nCode\n#Choix du thème\nmf_theme(\"darkula\")\n# Trace les Iris avec des paramètres\nmf_map(map_iris,  type = \"base\",\n       border=\"white\",\n        lwd=0.3)\n# Ajoute les contours des arrondissements\nmf_map(map_arr,  type = \"base\", \n       col = NA, lwd=1,\n       add = TRUE)\n# Ajoute les contours des communes\nmf_map(map_com,  type = \"base\", \n       col = NA, lwd=2,\n       add = TRUE)\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Marseille\", \n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#ajout-de-texte",
    "href": "04-carto-statique.html#ajout-de-texte",
    "title": "Carto statique",
    "section": "Ajout de texte",
    "text": "Ajout de texte\nOn peut ajouter une couche de texte avec la fonction mf_label(). Par exemple, on va ajouter à la carte précédente le code insee des communes\n\nrésultat\n\n\nCode\nmf_theme(\"agolalight\")\n\n# Trace les Iris avec des paramètres\nmf_map(map_iris, \n       type = \"base\", \n       col = \"lightyellow\",\n       border=\"gray80\",\n       lwd=0.3)\n\n# Ajoute les contours des arrondissements\nmf_map(map_arr, \n       type = \"base\", \n       col = NA,\n       border=\"red\",\n       lwd=1,\n       add = TRUE)\n\n# Ajoute les contours des communes\nmf_map(map_com,  type = \"base\", \n       col = NA,border=\"red\",lwd=2,\n       add = TRUE)\n\n# Ajoute les codes des arrondissements\nmap_arr$num&lt;-substr(map_arr$NOM_COM,10,13)\nmf_label(map_arr, \n         var=\"num\",\n         cex=0.7, \n         col=\"blue\",\n         overlap = FALSE)\n\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Arrondissements et Iris de Marseille en 2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-de-stock",
    "href": "04-carto-statique.html#carte-de-stock",
    "title": "Carto statique",
    "section": "Carte de stock",
    "text": "Carte de stock\nUne carte de stock représente la localisation de quantités que l’on peut aditionner et dont le total a un sens. Par exemple un nombre d’habitants, un nombre de ménages, un nombre d’automobiles. Ce quantités doivent être représentées par des figures (cercles, carrés, …) dont la surface est proportionelle au stock afin que l’oeil du lecteur puisse les aditionner visuellement.\nDans le package mapsf, on réalise ce type de carte à l’aide de la fonction mf_map()en lui donnant le paramètre type=\"prop\".\nOn va tenter à titre d’exemple de représenter la distribution du nombre de ménages ordinaires occupant un logement HLM par IRIS :\n\nCarte de stock minimale\n\n\nCode\n# Trace les contours des communes\nmf_map(x= map_iris, \n       type = \"base\")\n\n# Ajoute le nombre de ménages par IRIS\nmf_map(x =map_iris_hlm, \n      type =\"prop\",\n      var = \"HLM_1\",\n      add=TRUE)\n\n\n\n\n\nMais le résultat est peu satisfaisant car les cercles sont trop grands. Il faut en pratique toujours effectuer un réglage de ceux-ci avec l’instruction inches=\n\n\nCarte de stock habillée\n\n\nCode\nmf_theme(\"agolalight\")\nmf_map(map_iris, type = \"base\",  \n       col = \"lightyellow\",border=\"gray80\", lwd=0.3)\nmf_map(map_arr, type = \"base\", \n       col = NA,border=\"black\",lwd=1,add = TRUE)\n\nmf_map(map_iris_hlm, var = \"HLM_1\",type = \"prop\",\n  inches = 0.05, col = \"red\",leg_pos = \"left\",  \n  leg_title = \"Nombre de ménages\", add=TRUE)\n\nmf_layout(title = \"Distribution des logements HLM en 2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-choroplèthe",
    "href": "04-carto-statique.html#carte-choroplèthe",
    "title": "Carto statique",
    "section": "Carte choroplèthe",
    "text": "Carte choroplèthe\nUne carte choroplèthe ou d’intensité représente un phénomène relatif dont la somme n’a pas de sens. Par exemple, il serait absurde d’aditionner les % de logement HLM des IRIS du Val de Marne. Ces variables d’intensité caractèrisent donc l’état général d’une zone (choros) et elles vont être représentées par une couleur appliquée à toute la surface de la zone, d’où leur nom de cartes choroplèthes.\nLa fonction du package mapsf adaptée aux variables d’intensité est la fonction mf_map()munie du paramètre type = \"choro\".\nOn va prendre l’exemple de la part des ménages qui résident en HLM\n\nCarte choroplèthe minimale\nSi on ne précise rien, la carte est réalisée à l’aide de la palette par défaut avec un découpage des classes en quantiles (effectifs égaux).\n\n\nprogramme\n\n\nCode\n# Carte choroplèthe\nmf_map(\n  x = map_iris_hlm, \n  var = \"HLM_pct\",\n  type = \"choro\")\n\n\n\n\n\n\n\nCarte choroplèthe habillée\nOn peut arriver à une carte beaucoup plus satisfaisante en contrôlant l’ensemble des paramètres de couleur et de découpage des classes. Puis en superposant les contours de communes au dessus de la carte des IRIS pour faciliter le repérage.\n\n\nprogramme\n\n\nCode\nmybreaks = c(0, 10,20,30,40,50,\n             60,70,80,90, 100)\nmypal &lt;- mf_get_pal(n = 10, \n                    pal = \"Reds\",rev = T)\n# Carte choroplèthe des iris\nmf_map( map_iris_hlm, var = \"HLM_pct\",\n        type = \"choro\",\n        breaks = mybreaks,pal = mypal, \n        border=NA,\n       col_na = \"gray80\",leg_title = \"% HLM\",\n       leg_val_rnd = 0)\n# Contour des arrondissements et cadre\nmf_map(map_arr, type = \"base\", col = NA,\n       border=\"black\",lwd=1,add = TRUE)\nmf_layout(title = \"% de ménages en HLM au RP  2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-stock-choroplèthe-1",
    "href": "04-carto-statique.html#carte-stock-choroplèthe-1",
    "title": "Carto statique",
    "section": "Carte stock + choroplèthe (1)",
    "text": "Carte stock + choroplèthe (1)\nOn peut combiner les deux modes cartographiques par superposition :\n\n\nCode\nmf_theme(\"agolalight\")\n\n# Choisit les classes\nmybreaks = c(0,5,10,20,40,80,100)\n\n# Trace la carte choroplèthe\nmf_map(\n  x = map_iris_hlm, \n  var = \"HLM_pct\",\n  breaks = mybreaks,\n # pal=mypal,\n type = \"choro\",\n  border=\"white\",\n  col_na = \"gray80\",\n lwd=0.3,\n leg_title = \"% ménages\", \n leg_val_rnd = 0,\n  \n)\n\n# Ajoute les cercles proportionnels\n\nmf_map(\n  x =map_iris_hlm, \n  var = \"HLM_1\",\n  type = \"prop\",\n  inches = 0.06, \n  col = \"red\",\n  leg_pos = \"right\",  \n  leg_title = \"Nb ménages\",\n  add=TRUE\n)\n# Ajoute les contours des arr\nmf_map(map_arr, \n       type = \"base\", \n       col = NA,\n       border=\"black\",\n       lwd=1,\n       add = TRUE)\n\n# Ajoute un cadre, un titre et des sources\nmf_layout(title = \"Les ménages ordinaires en HLM  2020\", \n          frame = TRUE,\n          credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "04-carto-statique.html#carte-stock-choroplèthe",
    "href": "04-carto-statique.html#carte-stock-choroplèthe",
    "title": "Carto statique",
    "section": "Carte stock + choroplèthe",
    "text": "Carte stock + choroplèthe\nMais les cercles dissimuent alors les plages de couleur, aussi on peut utiliser le type prop_choro qui place la variable choroplèthe à l’intérieur des cercles\n\n\nCode\nmf_theme(\"agolalight\")\nmybreaks = c(0, 10,20,30,40,50,60,70,80,90, 100)\nmypal &lt;- mf_get_pal(n = 10, pal = \"Reds\", rev=T)\nmf_map(map_iris_hlm, type = \"base\",  \n       col = \"gray80\",border=\"white\", lwd=0.3)\nmf_map(map_arr, type = \"base\", \n       col = NA,border=\"white\",lwd=1,add = TRUE)\nmf_prop_choro( x = map_iris_hlm,  var = c(\"TOT\", \"HLM_pct\"), \n  inches = 0.06, col_na = \"grey\", pal=mypal,\n  breaks = mybreaks, nbreaks = 4, lwd = 0.1,\n  leg_pos = c(\"right\", \"left\"),leg_val_rnd = c(0,0),\n  leg_title = c(\"nb. ménages\", \"% HLM\"),\n  add = TRUE)\nmf_layout(title = \"Les ménages ordinaires en HLM  2020\", \n          frame = TRUE, credits = \"Sources : IGN et INSEE\")"
  },
  {
    "objectID": "06-agregation_point.html",
    "href": "06-agregation_point.html",
    "title": "Agrégation spatiale",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(tidyr,quietly = T,warn.conflicts = F,verbose = F)\n#library(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(mapsf)"
  },
  {
    "objectID": "06-agregation_point.html#agrégation-par-iris",
    "href": "06-agregation_point.html#agrégation-par-iris",
    "title": "Agrégation spatiale",
    "section": "Agrégation par IRIS",
    "text": "Agrégation par IRIS\nIl existe deux possibilités :\n\nSoit agréger à l’aide du code IRIS fourni dans la base des logements\nSoit intersecter géométriquement la carte des logements avec celle des IRIS\n\nOn va retenir la première solution qui est plus simple … si les code IRIS sont exacts.\n\nNombre de logements sociaux par IRIS\n\n\nCode\n# Chargement du fichier des IRIS\nmap_iris&lt;-readRDS(\"res/map_iris.RDS\")\n\n# Chargement du fichier des logements\nlogt&lt;-readRDS(\"res/rpls.RDS\")\n\n# Création du code IRIS\nlogt &lt;- logt %&gt;% mutate(CODE_IRIS = as.numeric(paste0(PLG_CODE_COMMUNE2021, \"0\",PLG_IRIS2021)))\n\n# Agrégation\nlogt_iris&lt;-logt %&gt;% st_drop_geometry %&gt;% \n              group_by(CODE_IRIS) %&gt;% \n              summarise(nb = n()) \n\nmap_iris_logt &lt;- left_join(map_iris, logt_iris)\n\n\n\n\nCarte par IRIS\n\n\nCode\nmf_map(map_iris, type=\"base\",col=\"lightyellow\")\nmf_map(map_iris_logt, \n       type=\"prop\",\n       var=\"nb\",\n       col=\"red\",\n       inches=0.05,\n       leg_title = \"nb. de logements\")\nmf_layout(title = \"Distribution des logements sociaux par IRIS\",\n          credits = \"Source : RPLS 2020 et IGN\",\n          frame = TRUE,\n          scale = TRUE)"
  },
  {
    "objectID": "06-agregation_point.html#agrégation-par-adresse",
    "href": "06-agregation_point.html#agrégation-par-adresse",
    "title": "Agrégation spatiale",
    "section": "Agrégation par adresse",
    "text": "Agrégation par adresse\nNous revenons sur le package sf (spatial features) que nous avons déjà rencontré au moment de la création de cartes thématiques par IRIS ou communes à l’aide du package mapsf.\nIci le package sf va être utilisé pour cartographier non pas des zones mais des localisations ponctuelles. Il pourra être à nouveau couplé avec le logiciel de cartogaphie statique comme mapsf , afin par exemple de placer les localisations des logements sociaux au dessus du fonds de carte des IRIS ou communes.\nMais il pourra aussi servir de base à des cartographies dynamiques permettant de placer les points sur des réseaux de rue et plus généralement sur des “tuiles” cartographiques permettant d’effectur des zoom. On utilisera à cet effet d’autres packages comme leaflet ou sa version simplifiée mapview.\n\nChargement des données\nNous chargeons le fichier des logements dans sa version géométrique c’est-à-dire comportant la position géométrique des unités spatiales. Nous le recodons et nous lui ajoutons les coordonnées X et Y des points de localisation.\n\n\nCode\nrpls&lt;-readRDS(\"res/rpls_geom.RDS\")\n\nsel&lt;-rpls %&gt;% select(nbp = NBPIECE,\n                     sup = SURFHAB,\n                     anc = CONSTRUCT,\n                     ene = DPEENERGIE,\n                     fin = FINAN) \n\nsel$fin &lt;- case_when(sel$fin == \"10\" ~ \"1.PLAI\",\n                     sel$fin == \"11\" ~ \"1.PLAI\",\n                     sel$fin == \"12\" ~ \"2.PLUS\",\n                     sel$fin == \"13\" ~ \"2.PLUS\",\n                     sel$fin == \"14\" ~ \"3.PLS\",\n                     sel$fin == \"15\" ~ \"3.PLS\",\n                     sel$fin == \"16\" ~ \"4.PLI\",\n                     sel$fin == \"17\" ~ \"4.PLI\",\n                     sel$fin == \"50\" ~ \"2.PLUS\",\n                     sel$fin == \"51\" ~ \"2.PLUS\",\n                     sel$fin == \"52\" ~ \"2.PLUS\",\n                     sel$fin == \"53\" ~ \"2.PLUS\",\n                     sel$fin == \"54\" ~ \"2.PLUS\",\n                     sel$fin == \"55\" ~ \"2.PLUS\",\n                     .default = \"0.Autre\"\n                     )\n\n\n\ncoo&lt;-st_coordinates(sel)\nsel$X&lt;-coo[,1]\nsel$Y&lt;-coo[,2]\n\n\nsel&lt;-st_drop_geometry(sel)\n\n\n\n\nAgrégation par pseudo-adresse\nOn va considérer que chaque point (X,Y) correspond à une adresse - ce qui n’est pas toujours vrai - et reconstiuer un fichier agrégé par pseudo-adresse. On devrait obtenir ainsi une carte plus précise que la précédente.\n\n\nCode\nmap_adr&lt;-sel %&gt;% st_drop_geometry %&gt;% \n              group_by(X,Y) %&gt;% \n              summarise(nb = n(),\n                        nbp_moy = mean(nbp),\n                        sup_moy = mean(sup),\n                        anc_moy = mean(anc),\n                        ene_min = min(ene),\n                        fin_min = min(fin)) \n\nmap_adr&lt;-st_as_sf(map_adr,coords = c(\"X\",\"Y\"))\nst_crs(map_adr)&lt;-2154\nhead(map_adr)\n\n\nSimple feature collection with 6 features and 6 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 887072.2 ymin: 6254194 xmax: 887107.4 ymax: 6254276\nProjected CRS: RGF93 v1 / Lambert-93\n# A tibble: 6 × 7\n     nb nbp_moy sup_moy anc_moy ene_min fin_min           geometry\n  &lt;int&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;          &lt;POINT [m]&gt;\n1     1    5       83      1986 E       1.PLAI  (887072.2 6254276)\n2     1    5       91      1986 E       1.PLAI  (887073.2 6254260)\n3     1    6      102      1986 E       1.PLAI  (887074.2 6254243)\n4     1    5       83      1986 E       1.PLAI  (887080.1 6254220)\n5    13    2.69    58.2    1986 E       1.PLAI  (887092.7 6254207)\n6     6    3.5     68.7    1986 E       1.PLAI  (887107.4 6254194)\n\n\n\n\nCarte par adresse\nOn procède à un test rapide de superposition sur la carte communale.\n\n\nCode\nmap_com&lt;-readRDS(\"res/map_com.RDS\")\nmf_map(map_com, type=\"base\",col=\"lightyellow\")\nmf_map(map_adr, \n       type=\"prop\",\n       var=\"nb\",\n       col=\"red\",\n       border = NA,\n       inches=0.05,\n       leg_title = \"nb. de logements\")\nmf_layout(title = \"Distribution des logements sociaux par adresse\",\n          credits = \"Source : RPLS et IGN\",\n          frame = TRUE,\n          scale = TRUE)\n\n\n\n\n\n\n\nSauvegarde\nOn sauvegarde le fonds de carte des données par adresse\n\n\nCode\nsaveRDS(map_adr,file = \"res/logt_adr.RDS\")"
  },
  {
    "objectID": "05-exploration.html",
    "href": "05-exploration.html",
    "title": "Exploration",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\n#library(sf,quietly = T, verbose=F)\n\n# Packages d'enquête\n#library(xtable)\n#library(survey)\n#library(questionr)"
  },
  {
    "objectID": "05-exploration.html#préparation-des-données",
    "href": "05-exploration.html#préparation-des-données",
    "title": "Exploration",
    "section": "Préparation des données",
    "text": "Préparation des données\nLe tableau du RPLS demande à être préparé soigneusement avant toute analyse statistique\n\nSélection des variables\nOn décide de sélectionner un nombre limité d’indicateurs dont on veut mesurer la distribution globale pour l’ensemble de la zone d’étude.\n\n\nCode\nrpls&lt;-readRDS(\"res/rpls.RDS\")\n\nsel&lt;-rpls %&gt;% select(nbp = NBPIECE,\n                     sup = SURFHAB,\n                     anc = CONSTRUCT,\n                     ene = DPEENERGIE,\n                     fin = FINAN) \n\n\n\n\nRecodage du type de financement\nOn procède à un recodage du type de financement en quatre catégories correspondant aux différents niveaux de logement social. On décide d’éliminer les cas complexes qui ne rentrent pas dans les quatre catégories\nN.B. Avant de transformer la variable en facteur, on a indiqué un order 1. 2. 3. 4. devant chaque type de financement afin que les graphiques qu nous réaliserons utilise un ordre logique.\n\n\nCode\nsel$fin &lt;- case_when(sel$fin == \"10\" ~ \"1.PLAI\",\n                     sel$fin == \"11\" ~ \"1.PLAI\",\n                     sel$fin == \"12\" ~ \"2.PLUS\",\n                     sel$fin == \"13\" ~ \"2.PLUS\",\n                     sel$fin == \"14\" ~ \"3.PLS\",\n                     sel$fin == \"15\" ~ \"3.PLS\",\n                     sel$fin == \"16\" ~ \"4.PLI\",\n                     sel$fin == \"17\" ~ \"4.PLI\",\n                     sel$fin == \"50\" ~ \"2.PLUS\",\n                     sel$fin == \"51\" ~ \"2.PLUS\",\n                     sel$fin == \"52\" ~ \"2.PLUS\",\n                     sel$fin == \"53\" ~ \"2.PLUS\",\n                     sel$fin == \"54\" ~ \"2.PLUS\",\n                     sel$fin == \"55\" ~ \"2.PLUS\",\n                     .default = NA\n                     )\nsel$fin&lt;-as.factor(sel$fin)\n\n\n\n\nRecodage de la consommation d’énergie\n\n\nCode\nsel$ene&lt;-as.factor(sel$ene)\n\n\n\n\nRésumé rapide\n\n\nCode\nsummary(sel)\n\n\n      nbp             sup              anc            ene            fin       \n Min.   :1.000   Min.   : 10.00   Min.   :1830   D      :25019   1.PLAI: 4820  \n 1st Qu.:3.000   1st Qu.: 51.00   1st Qu.:1961   C      :24785   2.PLUS:59784  \n Median :3.000   Median : 64.00   Median :1970   B      : 5658   3.PLS : 4931  \n Mean   :3.197   Mean   : 63.77   Mean   :1974   A      : 2959   4.PLI :  154  \n 3rd Qu.:4.000   3rd Qu.: 76.00   3rd Qu.:1989   E      : 2914   NA's  : 3083  \n Max.   :9.000   Max.   :230.00   Max.   :2019   (Other):  343                 \n                                                 NA's   :11094"
  },
  {
    "objectID": "05-exploration.html#analyse-univariée",
    "href": "05-exploration.html#analyse-univariée",
    "title": "Exploration",
    "section": "Analyse univariée",
    "text": "Analyse univariée\nOn décide d’analyser plus précisément les caractéristiques des logements en fonction de leur type de financement. On définit une palette que l’on juge convenable pour représenter les différents types de logement.\n\nType de financement\nOn réalise un tableau de dénombrement :\n\n\nCode\nsel %&gt;% filter(is.na(fin)==FALSE) %&gt;% \n         count(fin) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n     fin     n        pct\n1 1.PLAI  4820  6.9164431\n2 2.PLUS 59784 85.7868530\n3  3.PLS  4931  7.0757221\n4  4.PLI   154  0.2209818\n\n\nOn utilise geom_bar pour créer un diagramme en bâtons. On ajoute une couleur avec un ordre indiquant l’ordre implicite des bénéficiaires du plus social au moins social\n\n\nCode\nmypal&lt;-c(\"red\",\"orange\",\"yellow\",\"lightyellow\")\n\nsel  %&gt;% filter(is.na(fin)==FALSE) %&gt;%\n              ggplot()+\n              aes(x=fin,fill=fin) + \n              geom_bar(stat=\"count\")+\n              scale_fill_manual(values=mypal) +\n              scale_x_discrete(\"Type de logement\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Frequence des types de logements sociaux\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nType énergétique\nOn reprend le programme précédent :\n\n\nCode\nsel %&gt;% filter(is.na(ene)==FALSE) %&gt;% \n         count(ene) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n  ene     n         pct\n1   A  2959  4.79749668\n2   B  5658  9.17344920\n3   C 24785 40.18450663\n4   D 25019 40.56389636\n5   E  2914  4.72453711\n6   F   307  0.49774636\n7   G    36  0.05836765\n\n\nOn réalise un diagramme en bâtons où l’on essaye de retrouver la palette de couleur des classes énergétiques\n\n\nCode\nmypal&lt;-c(\"darkgreen\",\"green4\",\"lightgreen\",\"yellow\",\"orange\",\"red1\",\"brown\")\nsel %&gt;% filter(is.na(ene)==F) %&gt;%\n              ggplot() + \n              aes(x=ene, fill=ene) + \n              geom_bar(stat=\"count\",na.rm = T,) + \n              scale_fill_manual(values=mypal) +\n              scale_x_discrete(\"Classe énergétique du logement\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Classe énergétique des logements sociaux\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nNombre de pièces\nCette variable quantitative discrètre peut être analysée de deux façons différentes. On choisit isic de la traiter comme une variable qualitative :\n\n\nCode\nsel %&gt;% filter(is.na(nbp)==FALSE) %&gt;% \n         count(nbp) %&gt;%\n         mutate(pct=100*n/sum(n))\n\n\n  nbp     n          pct\n1   1  4150  5.702742813\n2   2 11935 16.400538669\n3   3 28660 39.383279283\n4   4 22130 30.410047821\n5   5  5283  7.259660309\n6   6   561  0.770900896\n7   7    51  0.070081900\n8   8     1  0.001374155\n9   9     1  0.001374155\n\n\nOn transforme en variable catégorielle avant de réaliser le diagramme en bâtons\n\n\nCode\nsel %&gt;% ggplot() + aes(x=as.factor(nbp)) + \n              geom_bar(stat=\"count\") +\n              scale_x_discrete(\"Nombre de pièces\") +\n              scale_y_continuous(\"Effectif\") +\n              ggtitle(\"Taille des logements sociaux (en nombre de pièces)\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nSuperficie habitable\nLà il s’agit d’une véritable variable quantitative continue.\n\n\nCode\nsummary(sel$sup)\n\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  10.00   51.00   64.00   63.77   76.00  230.00 \n\n\nOn construit un histogramme puisque la variable est quantitative et continue. On utilise la fonction densité de probabilité pour mieux repérer les pics.\n\n\nCode\nggplot(sel %&gt;% filter(is.na(sup)==F, sup&lt;130))+ \n             aes(x=sup) + \n              geom_histogram(stat = \"density\") +\n              scale_x_continuous(\"Superficie habitable en m2\") +\n              scale_y_continuous(\"Probabilité\") +\n                ggtitle(\"Taille des logements sociaux (en superficie)\",\n                      subtitle = \"Source : RPLS 2020\" ) +\n              theme_light()\n\n\n\n\n\n\n\nAncienneté\nOn construit un histogramme puisque la variable est quantitative et continue. On utilise la fonction densité de probabilité pour mieux repérer les pics.\n\n\nCode\nggplot(sel %&gt;% filter(is.na(anc)==F, anc&gt;1900))+ \n             aes(x=anc) + \n              geom_histogram(stat=\"density\")+\n              scale_x_continuous(\"Date de construction des logements\") +\n              scale_y_continuous(\"Probabilité\")"
  },
  {
    "objectID": "05-exploration.html#analyse-bivariée",
    "href": "05-exploration.html#analyse-bivariée",
    "title": "Exploration",
    "section": "Analyse bivariée",
    "text": "Analyse bivariée\nOn donne juste quelques possibilités à titre d’exemple.\n\nX et Y qualitatives\nLes deux variables sont de type qualitatif. On va donc créer un tableau de contingence, analyser les profils puis utiliser un test du chi-2.\n\n\nCode\n# Tableau de contingence\ntab&lt;-table(sel$fin,sel$ene)\nkable(addmargins(tab), caption=\"Tableau de contingence\")\n\n\n\nTableau de contingence\n\n\n\nA\nB\nC\nD\nE\nF\nG\nSum\n\n\n\n\n1.PLAI\n530\n477\n1419\n1355\n297\n32\n13\n4123\n\n\n2.PLUS\n1723\n4148\n21877\n21748\n2147\n259\n15\n51917\n\n\n3.PLS\n700\n554\n898\n682\n107\n3\n5\n2949\n\n\n4.PLI\n0\n35\n53\n4\n54\n8\n0\n154\n\n\nSum\n2953\n5214\n24247\n23789\n2605\n302\n33\n59143\n\n\n\n\n\nCode\n# Pourcentages en ligne\ntab2&lt;-100*prop.table(addmargins(tab,1),1)\nkable(addmargins(tab2,2), digits=1, caption=\"Profil en ligne\")\n\n\n\nProfil en ligne\n\n\n\nA\nB\nC\nD\nE\nF\nG\nSum\n\n\n\n\n1.PLAI\n12.9\n11.6\n34.4\n32.9\n7.2\n0.8\n0.3\n100\n\n\n2.PLUS\n3.3\n8.0\n42.1\n41.9\n4.1\n0.5\n0.0\n100\n\n\n3.PLS\n23.7\n18.8\n30.5\n23.1\n3.6\n0.1\n0.2\n100\n\n\n4.PLI\n0.0\n22.7\n34.4\n2.6\n35.1\n5.2\n0.0\n100\n\n\nSum\n5.0\n8.8\n41.0\n40.2\n4.4\n0.5\n0.1\n100\n\n\n\n\n\nCode\n# Graphique\nmypal&lt;-c(\"darkgreen\",\"green4\",\"lightgreen\",\"yellow\",\"orange\",\"red1\",\"brown\")\nplot(tab, col=mypal, main = \"Type de logement et isolation énergétique\")\n\n\n\n\n\nCode\n# Test du chi-2\ntest&lt;-chisq.test(tab)\n\n\nWarning in chisq.test(tab): Chi-squared approximation may be incorrect\n\n\nCode\ntest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tab\nX-squared = 4387.8, df = 18, p-value &lt; 0.00000000000000022\n\n\nLe test du chi2 est incorrect car certaines catégories énergétiques sont trop peu représentées. On procède donc à des regroupements et on applique le même programme.\n\n\nCode\n# Fusion des classes\nsel$ene4&lt;-sel$ene\nlevels(sel$ene4)&lt;-c(\"AB\",\"AB\",\"C\",\"D\",\"EFG\",\"EFG\",\"EFG\")\n\n# Tableau de contingence\ntab&lt;-table(sel$fin,sel$ene4)\nkable(addmargins(tab), caption=\"Tableau de contingence\")\n\n\n\nTableau de contingence\n\n\n\nAB\nC\nD\nEFG\nSum\n\n\n\n\n1.PLAI\n1007\n1419\n1355\n342\n4123\n\n\n2.PLUS\n5871\n21877\n21748\n2421\n51917\n\n\n3.PLS\n1254\n898\n682\n115\n2949\n\n\n4.PLI\n35\n53\n4\n62\n154\n\n\nSum\n8167\n24247\n23789\n2940\n59143\n\n\n\n\n\nCode\n# Pourcentages en ligne\ntab2&lt;-100*prop.table(addmargins(tab,1),1)\nkable(addmargins(tab2,2), digits=1, caption=\"Profil en ligne\")\n\n\n\nProfil en ligne\n\n\n\nAB\nC\nD\nEFG\nSum\n\n\n\n\n1.PLAI\n24.4\n34.4\n32.9\n8.3\n100\n\n\n2.PLUS\n11.3\n42.1\n41.9\n4.7\n100\n\n\n3.PLS\n42.5\n30.5\n23.1\n3.9\n100\n\n\n4.PLI\n22.7\n34.4\n2.6\n40.3\n100\n\n\nSum\n13.8\n41.0\n40.2\n5.0\n100\n\n\n\n\n\nCode\n# Graphique\n\nmypal&lt;-c(\"darkgreen\",\"lightgreen\",\"yellow\",\"orange\")\nplot(tab, col=mypal, main = \"Type de logement et isolation énergétique\")\n\n\n\n\n\nCode\n# Test du chi-2\ntest&lt;-chisq.test(tab)\ntest\n\n\n\n    Pearson's Chi-squared test\n\ndata:  tab\nX-squared = 3336.8, df = 9, p-value &lt; 0.00000000000000022\n\n\n\n\nY quantitative et X qualitative\nOn va prendre comme exemple la relation entre la surface des logements et leur type de financement. On commence par calculer les paramètres principaux, puis on fait un graphique et enfin on teste l’existence d’une relation.\n\n\nCode\n# Paramètres principaux\ntapply(sel$sup, sel$fin,summary, simplify=T)\n\n\n$`1.PLAI`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n     14      49      65      64      77     190 \n\n$`2.PLUS`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   10.0    53.0    65.0    64.6    76.0   230.0 \n\n$`3.PLS`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  15.00   44.00   63.00   58.37   72.00  128.00 \n\n$`4.PLI`\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   37.0    56.0    70.0    67.9    80.0   101.0 \n\n\nCode\n# Boxplot\nsel %&gt;% filter(is.na(fin) == F) %&gt;%\n                   ggplot() + aes(y=sup, x=fin) +\n                   geom_boxplot() +\n                   scale_x_discrete(\"Type de logement\") +\n                   scale_y_continuous(\"Superficie habitable\") +\n                   ggtitle(\"Superficie en fonction du type de logement social\",\n                           subtitle = \"Source : RPLS 2020\" )\n\n\n\n\n\nCode\n# Analyse de variance\nmod &lt;- lm(sel$sup~sel$fin)\nsummary(mod)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$fin)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-54.604 -11.604   0.396  11.635 165.396 \n\nCoefficients:\n              Estimate Std. Error t value             Pr(&gt;|t|)    \n(Intercept)    64.0029     0.2492 256.834 &lt; 0.0000000000000002 ***\nsel$fin2.PLUS   0.6010     0.2591   2.320              0.02034 *  \nsel$fin3.PLS   -5.6375     0.3504 -16.087 &lt; 0.0000000000000002 ***\nsel$fin4.PLI    3.8932     1.4162   2.749              0.00598 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.3 on 69685 degrees of freedom\n  (3083 observations deleted due to missingness)\nMultiple R-squared:  0.008535,  Adjusted R-squared:  0.008492 \nF-statistic: 199.9 on 3 and 69685 DF,  p-value: &lt; 0.00000000000000022\n\n\nOn effectue un test :\n\n\nCode\nmod&lt;-lm(sel$sup~sel$fin)\nsummary(mod)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$fin)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-54.604 -11.604   0.396  11.635 165.396 \n\nCoefficients:\n              Estimate Std. Error t value             Pr(&gt;|t|)    \n(Intercept)    64.0029     0.2492 256.834 &lt; 0.0000000000000002 ***\nsel$fin2.PLUS   0.6010     0.2591   2.320              0.02034 *  \nsel$fin3.PLS   -5.6375     0.3504 -16.087 &lt; 0.0000000000000002 ***\nsel$fin4.PLI    3.8932     1.4162   2.749              0.00598 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.3 on 69685 degrees of freedom\n  (3083 observations deleted due to missingness)\nMultiple R-squared:  0.008535,  Adjusted R-squared:  0.008492 \nF-statistic: 199.9 on 3 and 69685 DF,  p-value: &lt; 0.00000000000000022\n\n\n\n\nSuperficie et ancienneté\nOn calcule le coefficient de corrélation et l’équation de la droite de régression décrivant la relation entre superficie et date de construction.\n\n\nCode\ncor.test(sel$anc, sel$sup)\n\n\n\n    Pearson's product-moment correlation\n\ndata:  sel$anc and sel$sup\nt = 34.374, df = 72770, p-value &lt; 0.00000000000000022\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.1192475 0.1335464\nsample estimates:\n      cor \n0.1264035 \n\n\nCode\nmod2&lt;-lm(sel$sup~sel$anc)\nsummary(mod2)\n\n\n\nCall:\nlm(formula = sel$sup ~ sel$anc)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-53.58 -11.45   0.19  12.36 168.56 \n\nCoefficients:\n               Estimate  Std. Error t value            Pr(&gt;|t|)    \n(Intercept) -125.672212    5.511582  -22.80 &lt;0.0000000000000002 ***\nsel$anc        0.095953    0.002791   34.37 &lt;0.0000000000000002 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 17.4 on 72770 degrees of freedom\nMultiple R-squared:  0.01598,   Adjusted R-squared:  0.01596 \nF-statistic:  1182 on 1 and 72770 DF,  p-value: &lt; 0.00000000000000022\n\n\nOn réalise un graphique avec ggplot qui reproduit l’ajustement linéaire utilisé et on y ajoute un ajustement non linéaire afin de pouvoir visualiser la tendance générale et les cycles autour de celle-ci.\n\n\nCode\nsel %&gt;% ggplot() +aes(x=anc, y = sup) +\n                  geom_point(size=0.1) +\n                  geom_smooth(method=\"lm\",col=\"red\") +\n                  geom_smooth(col=\"blue\", se=F)+\n                  scale_x_continuous(\"Date de construction\") +\n                  scale_y_continuous(\"Surface habitable\",limits = c(0,150)) +\n                  ggtitle(\"Surface habitable et ancienneté des logements sociaux\") +\n                  theme_light()"
  },
  {
    "objectID": "03-agregation-spatiale.html",
    "href": "03-agregation-spatiale.html",
    "title": "Agrégation spatiale",
    "section": "",
    "text": "Code\n# Options générales\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\n\n# Selection de packages tidyverse\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(tidyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(ggplot2,quietly = T,warn.conflicts = F,verbose = F)\n\n# packages de cartographie\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\n# Packages d'enquête\n#library(xtable)\n#library(survey)\nlibrary(questionr)"
  },
  {
    "objectID": "03-agregation-spatiale.html#objectifs",
    "href": "03-agregation-spatiale.html#objectifs",
    "title": "Agrégation spatiale",
    "section": "Objectifs",
    "text": "Objectifs\nDans cet exercices on va agréger les données issues du recensement des ménages par IRIS puis effectuer une jointurer avec le fonds de carte des IRIS. S’il existe un niveau intermédiaire entre les arrondissements et la commune (les arrondissements), nous allons également agréger les données et le fonds de carte à ce niveau.\nLa cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets uniques rassemblant à la fois\n\nun tableau de données (l’équivalent du fichier .dbf)\nune géométrie (l’équivalent du fichier .shp)\nune projection (l’équivalent du fichier .prj)\n\nLorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf.\nNous allons suivre les étapes suivantes :\n\nPréparer les données statistiques par IRIS dans un data.frame\nCharger un fonds de carte par IRIS au format sf\nEffectuer une jointure entre les deux fichiers par le code IRIS\nSauvegarder le résultat\nAgréger les données statistiques et géométriques par arrondissement\nSauvegarder le résultat."
  },
  {
    "objectID": "03-agregation-spatiale.html#agrégation-des-ménages-par-iris",
    "href": "03-agregation-spatiale.html#agrégation-des-ménages-par-iris",
    "title": "Agrégation spatiale",
    "section": "Agrégation des ménages par Iris",
    "text": "Agrégation des ménages par Iris\n\nPréparer les données statistiques\nOn importe le fichier des individus :\n\n\nCode\ntab_ind&lt;-readRDS(\"res/tabmen.RDS\")\n\n\n\n\nFALSE   X COMMUNE   ARM      IRIS ACHL\nFALSE 1 1   13055 13201 132010101  B11\nFALSE 2 2   13055 13201 132010101  A12\nFALSE 3 3   13055 13201 132010101  B11\n\n\n\n\nAgréger les données\nOn commence par créer un tableau long croisant les deux variables et leur effectif pondéré :\n\n\nCode\ntab_long&lt;- tab_ind %&gt;%\n           filter(HLML != \"Y\")%&gt;%\n           group_by(IRIS,HLML)%&gt;%\n           summarise(NB=sum(IPONDL))\n\n\n\n\n\n\n\nIRIS\nHLML\nNB\n\n\n\n\n132010101\n1\n25.71\n\n\n132010101\n2\n640.22\n\n\n132010102\n1\n125.14\n\n\n132010102\n2\n1060.17\n\n\n132010103\n1\n74.18\n\n\n\n\n\n\n\nPivoter le tableau\nPuis on fait “pivoter” le tableau pour l’obtenir en format large :\n\n\nCode\ntab_large &lt;- tab_long %&gt;% pivot_wider(id_cols = IRIS, \n                                      names_from = HLML,\n                                      names_prefix = \"HLM_\",\n                                      values_from = NB,\n                                      values_fill = 0)\n\n\n\n\n\n\n\nIRIS\nHLM_1\nHLM_2\n\n\n\n\n132010101\n25.71\n640.22\n\n\n132010102\n125.14\n1060.17\n\n\n132010103\n74.18\n1104.85\n\n\n132010104\n176.46\n1444.42\n\n\n132010201\n35.17\n1147.65\n\n\n\n\n\n\n\nAjouter de nouvelles variables\nOn ajoute de nouvelles variables telles que le nombre total de ménage et le % de ménages en HLM :\n\n\nCode\ntab&lt;- tab_large %&gt;% mutate(TOT = HLM_1+HLM_2,\n                           HLM_pct = 100*HLM_1/TOT)\n\n\n\n\n\n\n\nIRIS\nHLM_1\nHLM_2\nTOT\nHLM_pct\n\n\n\n\n132010101\n25.71\n640.22\n665.93\n3.86\n\n\n132010102\n125.14\n1060.17\n1185.31\n10.56\n\n\n132010103\n74.18\n1104.85\n1179.02\n6.29\n\n\n132010104\n176.46\n1444.42\n1620.87\n10.89\n\n\n132010201\n35.17\n1147.65\n1182.82\n2.97\n\n\n\n\n\n\n\nExaminer la distribution statistique\nOn examine l’histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par IRIS.\n\n\nCode\np &lt;- ggplot(tab) + aes (x = HLM_pct) +\n                   geom_histogram(breaks = c(0,10,20,30,40,50,\n                                             60,70,80,90, 100)) +\n                   scale_x_continuous(\"% de ménages en HLM\") +\n                   scale_y_continuous(\"Nombre d'IRIS\") +\n                   ggtitle(label = \"Distribution des logements sociaux à Marseille par IRIS\",\n                           subtitle = \"Source : INSEE, RP 2020\")\n\n\n\n\n\n\n\n\n\nCharger les données géométriques\nOn importe le fichier des iris qui est au format sf en ne gardant que les colonnes utiles et en les renommant si besoin\n\n\nCode\nmap_iris &lt;- readRDS(\"res/map_iris.RDS\")\nmap_iris&lt;-map_iris[,c(5, 6,2,3,8)]\nnames(map_iris)&lt;-c(\"IRIS\",\"NOM_IRIS\",\"ARR\",\"NOM_ARR\",\"geometry\")\n\n\n\n\nFALSE [1] \"sf\"         \"data.frame\"\n\n\n\n\n\nIRIS\nNOM_IRIS\nARR\nNOM_ARR\n\n\n\n\n132060301\nBergers\n13206\nMarseille 6e Arrondissement\n\n\n132060602\nVauban-Fénelon\n13206\nMarseille 6e Arrondissement\n\n\n\n\n\n\n\nJointure des données IRIS et du fonds de carte\n\n\nCode\nmap_iris_tab&lt;-merge(map_iris,tab,\n                   by.x=\"IRIS\",by.y=\"IRIS\",\n                   all.x=T,all.y=F)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIRIS\nNOM_IRIS\nARR\nNOM_ARR\nHLM_1\nHLM_2\nTOT\nHLM_pct\ngeometry\n\n\n\n\n132010101\nLa Bourse\n13201\nMarseille 1er Arrondissement\n25.71\n640.22\n665.93\n3.86\nMULTIPOLYGON (((892644.6 62…\n\n\n132010102\nThubaneau\n13201\nMarseille 1er Arrondissement\n125.14\n1060.17\n1185.31\n10.56\nMULTIPOLYGON (((893235.8 62…\n\n\n132010103\nColbert-Providence\n13201\nMarseille 1er Arrondissement\n74.18\n1104.85\n1179.02\n6.29\nMULTIPOLYGON (((892650.8 62…\n\n\n\n\n\n\n\nCarte sommaire\nOn fait une carte rapide pour vérifier le résultat\n\n\nCode\nplot(map_iris_tab['HLM_pct'])\n\n\n\n\n\n\n\nSauvegarde du fichier par IRIS\nOn sauvegarde notre fichier au format .RDS de R\n\n\nCode\nsaveRDS(map_iris_tab,\"res/map_iris_hlm.RDS\")"
  },
  {
    "objectID": "03-agregation-spatiale.html#agrégation-des-iris-par-arrondissement",
    "href": "03-agregation-spatiale.html#agrégation-des-iris-par-arrondissement",
    "title": "Agrégation spatiale",
    "section": "Agrégation des iris par arrondissement",
    "text": "Agrégation des iris par arrondissement\nGrâce aux nouveaux packages de R (dplyr et sf) il est possible d’agréger simultanément les statistiques et les géométries après les avoir stockés dans un même objet de type “sf”\nDu coup, on peut gagner beaucoup de temps dans les traitements et les analyses cartographiques, en particulier si l’on veut tester différents niveaux d’agrégation.\n\nAgrégation stat + geom\nL’agrégation est très facile et elle concerne à la fois les variables (de stock) et les geometries\n\n\nCode\nmap_arr_tab &lt;- map_iris_tab %&gt;% \n  group_by(ARR, NOM_ARR) %&gt;% \n  summarise(HLM_1=sum(HLM_1,na.rm=T), \n            HLM_2=sum(HLM_2,na.rm=T)) %&gt;%\n  st_cast(\"MULTIPOLYGON\")\n\nmap_arr_tab &lt;- map_arr_tab %&gt;%  mutate(TOT = HLM_1+HLM_2,\n                                  HLM_pct = 100*HLM_1/TOT) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nARR\nNOM_ARR\nHLM_1\nHLM_2\nTOT\nHLM_pct\n\n\n\n\n13201\nMarseille 1er Arrondissement\n747.12\n20142.62\n20889.74\n3.58\n\n\n13202\nMarseille 2e Arrondissement\n2203.69\n9951.52\n12155.21\n18.13\n\n\n13203\nMarseille 3e Arrondissement\n4499.22\n17810.20\n22309.43\n20.17\n\n\n\n\n\n\n\nRésultat statistique\nOn examine l’histogramme donnant distribution statistique du % de ménages ordinaires résidant en HLM par Arrondissement.\n\n\nCode\np &lt;- ggplot(map_arr_tab) + aes (x = HLM_pct) +\n                   geom_histogram(breaks = c(0,10,20,30,40,50,\n                                             60,70,80,90,100)) +\n                   scale_x_continuous(\"% de ménages en HLM\") +\n                   scale_y_continuous(\"Nombre d'arrondissement\") +\n                   ggtitle(label = \"Distribution des logements sociaux à Marseille par arrondissement\",\n                           subtitle = \"Source : INSEE, RP 2020\")\n\n\n\n\n\n\n\n\n\nRésultat cartographique\nOn fait une carte sommaire avec sf\n\n\nCode\nplot(map_arr_tab['HLM_pct'])\n\n\n\n\n\n\n\nSauvegarde du fichier par arrondissements\nOn sauvegarde notre fichier au format .RDS de R\n\n\nCode\nsaveRDS(map_arr_tab,\"data/map_arr_hlm.RDS\")"
  },
  {
    "objectID": "01-Data.html",
    "href": "01-Data.html",
    "title": "Préparation des données",
    "section": "",
    "text": "Code\nlibrary(knitr)\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\nlibrary(dplyr,quietly = T,warn.conflicts = F,verbose = F)\nlibrary(sf,quietly = T, verbose=F)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE"
  },
  {
    "objectID": "01-Data.html#introduction",
    "href": "01-Data.html#introduction",
    "title": "Préparation des données",
    "section": "Introduction",
    "text": "Introduction\nPour commencer, vous devez télécharger le dossier contenant l’ensembles des données à l’adresse suivante et le décompresser.\nVous allez ensuite créer à l’intérieur un dossier respour y stocker vos propres données et ouvrir un projet R. Enfin vous allez créer un document quarto appel prepare_data.qmd et vous trouver dans la situation suivante.\n\n\n\nsituation de départ\n\n\nVous pouvez désormais recopier les différents fragements de programme présentés ci-dessous qui vont vous permettre de transférer dans votre dossier res les fichiers utiles pour l’étude de votre commune. Une fois l’opération faite, vous pourrez détruire les dossiers data et meta…"
  },
  {
    "objectID": "01-Data.html#rp-logement-2020-insee",
    "href": "01-Data.html#rp-logement-2020-insee",
    "title": "Préparation des données",
    "section": "RP Logement 2020 (INSEE)",
    "text": "RP Logement 2020 (INSEE)\nNous partons des fichiers détail de l’INSEE car, à la différence des tableaux prédéfinis, ils permettent virtuellement toutes les formes de croisement d’indicateurs. Ils sont évidemment très volumineux mais ici vous avez la chance de bénéficier d’une extraction des communes sur lesquelles vous allez travailler\n\nEtape 1 : Importation des données au format R\nComme les fichiers sont d’assez petite taille, on se contentera d’utiliser la fonctionread.csv qui fait partie du R-base :\n\n\nCode\nt1&lt;-Sys.time()\ntab&lt;-read.csv(\"data/rplogmt_13055.csv\")\nt2&lt;-Sys.time()\npaste (\"chargement effectué en\",t2-t1,\"secondes\")\ndim(tab)\nclass(tab)\n\n\nDans l’exemple choisi (Marseille) le tableau ne comporte que 182735 individus et se charge en moins d’une seconde\nToutefois, si vous êtes amenés à traiter directement des fichiers de l’INSEE comportant plusieurs millions d’enregistrement vous aurez intérêt à utiliser des fonctions plus puissantes comme la fonction read_csv2 du package readr ou, miuex encore, la fonction fread du package data.table\n\n\nEtape 2 : Sélection des données utiles et sauvegarde au format .RDS\nNos tableaux peuvent être enregistés au format interne de .R ce qui réduira considérablement leur taille par rapport au fichier texte au format .csv qui pèse en général beaucoup plus.\nComme ces données vont nous servir durant tout le projet, elles seront stockées dans le dossier res qui sera spécifique à l’exemple retenu.\n\n\nCode\n## Sauvegarde au format RDS\nsaveRDS(object = tab,\n        file = \"res/tabmen.RDS\")\n\n\n\nEtape 3 : Chargement et sauvegarde des méta-données\nIl ne faut surtout pas oublier le fichier des métadonnées qui va permettre de recoder facilement tous les facteurs et de décoder les chiffres correspondant aux classes. On va donc le transformer au format R puis l’enregistrer également dans le dossier res. Noter qu’on utilise cette fois-ci la fonction read.csv2car le séparateur de colonne n’est plus la virgule (ce qu’on lit avec read.csv) mais le point virgule.\n\n\nCode\n# Lecture du fichier de métadonnées\nmeta&lt;-read.csv2(\"meta/Dictionnaire variables_logemt_2020.csv\")\n# Enregistrement dans le dossier data\nsaveRDS(object = meta,\n        file = \"res/tabmen_meta.RDS\")"
  },
  {
    "objectID": "01-Data.html#géométries-2020-ign",
    "href": "01-Data.html#géométries-2020-ign",
    "title": "Préparation des données",
    "section": "Géométries 2020 (IGN)",
    "text": "Géométries 2020 (IGN)\nLes contours des unités spatiales correspondant aux codes de l’INSEE sont produits par l’IGN et disponibles sur le site géoservice en accès libre. En général on récupère un très gros fichier pour la France entière ce qui demande un peu de travail pour extraire juste la zone d’étude. Ici vous avez de la chance puisqu’on vous a déjà extrait le fichier relatif à votre commune\n\nEtape 1 : Importation et transformation au format sf\nLa cartographie et plus généralement les opérations géométriques sur des données spatiales dans R peuvent facilement être effectuées avec le package sf (spatial features) qui crée des objets ubniques rassemblant à la fois\n\nun tableau de données (l’équivalent du fichier .dbf)\nune géométrie (l’équivalent du fichier .shp)\nune projection (l’équivalent du fichier .prj)\n\nLorsqu’on récupère des fonds de carte au format shapefile (.shp) ou dans d’autres formats standards comme GeoJson, la première tâche consiste donc à les convertir au formt sf afin de pouvoir les utiliser facilement dans R. L’importation se fait à l’aide de l’instruction st_read en indiquant juste le nom du fichier .shp à charger. Les autres fichiers (.dbf ou .proj) seront lus également et intégrés dans l’objet qui hérite de la double classe data.frame et sf.\n\n\nCode\nlibrary(sf)\nmap_iris &lt;- st_read(\"data/iris_13055.gml\")\n\n\nReading layer `iris_13055' from data source \n  `/Users/claudegrasland1/worldregio/hackaton2024/data/iris_13055.gml' \n  using driver `GML'\nSimple feature collection with 393 features and 7 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 881250.9 ymin: 6232998 xmax: 905587.3 ymax: 6257715\nProjected CRS: RGF93 Lambert 93\n\n\nCode\ndim(map_iris)\n\n\n[1] 393   8\n\n\nCode\nclass(map_iris)\n\n\n[1] \"sf\"         \"data.frame\"\n\n\nCode\nkable(head(map_iris,2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngml_id\nINSEE_COM\nNOM_COM\nIRIS\nCODE_IRIS\nNOM_IRIS\nTYP_IRIS\ngeometryProperty\n\n\n\n\niris_13055.0\n13206\nMarseille 6e Arrondissement\n301\n132060301\nBergers\nH\nMULTIPOLYGON (((893856.1 62…\n\n\niris_13055.1\n13206\nMarseille 6e Arrondissement\n602\n132060602\nVauban-Fénelon\nH\nMULTIPOLYGON (((892867.6 62…\n\n\n\n\n\nPour faciliter la compatibilité avec d’autres applications, la 8e colonne qui contient le contour des zones est renommée “geometry” plutôt que “geometryProperty”.\n\n\nCode\nst_geometry(map_iris) &lt;-\"geometry\"\n\n\n\n\nEtape 2 : Visualisation des IRIS de la zone d’étude\nLe nouveau tableau ne comporte plus que 393 unités spatiales et 8 colonnes On peut visualiser rapidement le résultat à l’aide de la fonction plotdu package sf :\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry)\n\n\n\n\n\nOn sauvegarde le résultat dans notre dossier res au format interne de R :\n\n\nCode\nsaveRDS(object = map_iris,\n        file = \"res/map_iris.RDS\")\n\n\n\n\nEtape 3 : Carte des arrondissements\nComme nous serons amenés à travailler à plusieurs échelles, nous produisons tout de suite un fonds de carte des arrondissements en utilisant les fonctions d’agrégation du packages sf combinées avec celles de dplyr.\n\n\nCode\nmap_arr &lt;- map_iris  %&gt;% group_by(INSEE_COM) %&gt;%\n                        summarise(NOM_COM = min(NOM_COM)) %&gt;%\n                        st_as_sf()\n\n\non vérifie que l’agrégation s’est bien passée :\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_arr$geometry)\n\n\n\n\n\nEt on sauvegarde le fonds de carte\n\n\nCode\nsaveRDS(object = map_arr,\n        file = \"res/map_arr.RDS\")\n\n\n\n\nEtape 4 : création d’un contour complet de la commune\nEnfin, on construit un fonds de carte de l’ensemble de la commune étudiée\n\n\nCode\n# Agrégation\nmap_com &lt;- map_iris  %&gt;%     mutate(tot = \"Marseille\") %&gt;%\n                        group_by(tot) %&gt;%\n                        summarise() %&gt;%\n                        st_as_sf()\n# Visualisation\npar(mar=c(0,0,0,0))\nplot(map_com$geometry)\n\n\n\n\n\nCode\n# Sauvegarde\nsaveRDS(object = map_com,\n        file = \"res/map_com.RDS\")\n\n\n\n\nEtape 5 : Superposition des trois fonds de carte\nLa fonction plot du package sf permet de superposer des couches cartographiques avec l’instruction add=TRUE. Elle permet également de régler les couleurs des polygones (col=) ainsi que la couleur et l’épaisseur des frontières (border= et lwd=). Lorsqu’on ne souhaite pas remplir les polygones on indique col=NULL.\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry, col= \"lightyellow\", border = \"gray80\", lwd=0.5)\nplot(map_arr$geometry, col= NA, border = \"gray50\", lwd=1, add=TRUE)\nplot(map_com$geometry, col= NA, border = \"gray30\", lwd=2, add=TRUE)"
  },
  {
    "objectID": "01-Data.html#logement-social-2020",
    "href": "01-Data.html#logement-social-2020",
    "title": "Préparation des données",
    "section": "Logement social 2020",
    "text": "Logement social 2020\nLes données sur le logement social sont été téléchargées sur le site du ministère du développement durable :\n\nEtape 1 : Chargement du fichier\nOn charge le fichier qui comporte 182735 observation et 70 variables\n\n\nCode\nrpls&lt;-read.csv(\"data/rpls_13055.csv\")\nkable(head(rpls))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nX.1\nDROIT\nDEPCOM\nCODEPOSTAL\nLIBCOM\nNUMVOIE\nINDREP\nTYPVOIE\nNOMVOIE\nNUMAPPT\nNUMBOITE\nESC\nCOULOIR\nETAGE\nCOMPLIDENT\nENTREE\nBAT\nIMMEU\nCOMPLGEO\nLIEUDIT\nQPV\nTYPECONST\nNBPIECE\nSURFHAB\nCONSTRUCT\nLOCAT\nPATRIMOINE\nORIGINE\nFINAN\nFINANAUTRE\nCONV\nNUMCONV\nDATCONV\nNEWLOGT\nCUS\nDPEDATE\nDPEENERGIE\nDPESERRE\nSRU_EXPIR\nSRU_ALINEA\nCODSEGPATRIM\nLIBSEGPATRIM\nPMR\nREG\nLIBREG\nDEP\nLIBDEP\nEPCI\nLIBEPCI\nEPSG\nX\nY\nPLG_QP\nPLG_IRIS2021\nPLG_ZUS\nPLG_ZFU\nPLG_QVA\nPLG_CODE_COMMUNE2021\nQUALITE_VOIE\nQUALITE_NUMERO\nQUALITE_XY\nDISTANCE_PRECISION\nQUALITE_QP\nQUALITE_IRIS\nQUALITE_ZUS\nQUALITE_ZFU\nQUALITE_QVA\nCOMAQP\nCOMRIL\n\n\n\n\n1\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n103\nNA\nNA\nNA\n0\nNA\nNA\nNA\n184-BT1-1\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n3\n65\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n2\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n113\nNA\nNA\nNA\n1\nNA\nNA\nNA\n184-BT1-1\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n3\n65\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n3\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n114\nNA\nNA\nNA\n1\nNA\nNA\nNA\n184-BT1-1\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n5\n100\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n4\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n202\nNA\nNA\nNA\n0\nNA\nNA\nNA\n184-BT1-2\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n3\n65\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n5\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n123\nNA\nNA\nNA\n2\nNA\nNA\nNA\n184-BT1-1\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n3\n69\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n6\n1\n13055\n13009\nMarseille 9e Arrondissement\nNA\nNA\nNA\n55, Traverse de la Gouffonne\n124\nNA\nNA\nNA\n2\nNA\nNA\nNA\n184-BT1-1\nRESIDENCE LE MASSALIA I\nNA\n2\nC\n3\n69\n1995\n1998\n1998\n1\n12\n12\n1\n13204199785123110750722399\nNA\nNA\nNA\nNA\nB\nC\n2031\nNA\nSEG001\nMarseille Prov. Metropol\n1\n93\nProvence-Alpes-Côte d’Azur\n13\nBouches-du-Rhône\n200054807\nMétropole d’Aix-Marseille-Provence\n2154\n895698.9\n6241946\nHZ\n404\nHZ\nCSZ\nHZ\n13209\nNA\nNA\n11\nNA\n1\n1\n1\nNA\n1\n1\n1\n\n\n\n\n\nCode\nsaveRDS(rpls,\"res/rpls.RDS\")\n\n\nMais il faut retirer un certain nombre de lignes qui ne correspondent pas à des logements sociaux. On va donc utiliser le critère CONV==1 pour ne conserver que les logements conventionnés.\n\n\nCode\nrpls &lt;- rpls %&gt;% filter(CONV==1)\ndim(rpls)\n\n\n[1] 72772    69\n\n\nOn voit qu’il ne reste plus que 72772 lignes. On sauvegarde le résultat dans le dossier res.\n\n\nCode\nsaveRDS(rpls,\"res/rpls.RDS\")\n\n\n\n\nEtape 2 : Test de superposition géométrique\nLe fichier comporte deux colonnes X et Y dont on ignore la projection. On va tester leur superposition sur les fonds de carte précédents pour voir s’il s’agit de la même.\n\n\nCode\npar(mar=c(0,0,0,0))\nplot(map_iris$geometry, col= \"lightyellow\", border = \"gray80\", lwd=0.5)\nplot(map_arr$geometry, col= NA, border = \"gray50\", lwd=1, add=TRUE)\nplot(map_com$geometry, col= NA, border = \"gray30\", lwd=2, add=TRUE)\npoints(rpls$X, rpls$Y, col=\"red\",pch=20, cex=0.2)\n\n\n\n\n\nBingo, la superposition est parfaite donc la projection est la même. Il s’agit de la Lambert93 dont le CRS peut-être affiché par la commande st_crs() du package sf :\n\n\nCode\nst_crs(map_iris)\n\n\nCoordinate Reference System:\n  User input: RGF93 Lambert 93 \n  wkt:\nPROJCRS[\"RGF93 Lambert 93\",\n    BASEGEOGCRS[\"RGF93 geographiques (dms)\",\n        DATUM[\"Reseau Geodesique Francais 1993 v1\",\n            ELLIPSOID[\"GRS 1980\",6378137,298.257222101,\n                LENGTHUNIT[\"metre\",1]]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"IGNF\",\"RGF93G\"]],\n    CONVERSION[\"LAMBERT-93\",\n        METHOD[\"Lambert Conic Conformal (2SP)\",\n            ID[\"EPSG\",9802]],\n        PARAMETER[\"Latitude of false origin\",46.5,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8821]],\n        PARAMETER[\"Longitude of false origin\",3,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8822]],\n        PARAMETER[\"Latitude of 1st standard parallel\",44,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8823]],\n        PARAMETER[\"Latitude of 2nd standard parallel\",49,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8824]],\n        PARAMETER[\"Easting at false origin\",700000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8826]],\n        PARAMETER[\"Northing at false origin\",6600000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8827]]],\n    CS[Cartesian,2],\n        AXIS[\"easting (X)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"northing (Y)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"NATIONALE A CARACTERE LEGAL\"],\n        AREA[\"FRANCE METROPOLITAINE (CORSE COMPRISE)\"],\n        BBOX[41,-5.5,52,10]],\n    ID[\"IGNF\",\"LAMB93\"]]\n\n\nIl s’agit de la projection Lambert93 utilisée en France oar l’INSEE et l’IGN.\n\n\nEtape 3 : Carte des logements sociaux\nOn va alors pouvoir créer un fonds de carte géométrique de ces logements sociaux en indiquant la projection du fonds de carte des Iris.\n\n\nCode\n# Transformation du data.frame en objet sf\nrpls_geom&lt;-st_as_sf(rpls,coords = c(\"X\",\"Y\"))\n\n# Récupération du code EPSG de la projection\nst_crs(rpls_geom)&lt;-st_crs(map_iris)\n\n# Sauvegarde au format .RDS\nsaveRDS(rpls_geom, \"res/rpls_geom.RDS\")"
  },
  {
    "objectID": "01-Data.html#bilan",
    "href": "01-Data.html#bilan",
    "title": "Préparation des données",
    "section": "Bilan",
    "text": "Bilan\nNous avons désormais un dossier res qui comporte tous les éléments utiles pour l’analyse de notre zone d’étude.\n\nLe recensement des logements ordinaires en 2020 et ses métadonnées\nLes fonds de carte par iris, arrondissement et commune.\nLe fichier du RPLS pour l’année 2020 en version statistique ou cartographique\n\n\n\nCode\nlist.files(\"res\")\n\n\n[1] \"logt_adr.RDS\"     \"map_arr.RDS\"      \"map_com.RDS\"      \"map_iris_hlm.RDS\"\n[5] \"map_iris.RDS\"     \"rpls_geom.RDS\"    \"rpls.RDS\"         \"tabmen_meta.RDS\" \n[9] \"tabmen.RDS\""
  },
  {
    "objectID": "07-carto-leaflet.html",
    "href": "07-carto-leaflet.html",
    "title": "Carto-leaflet",
    "section": "",
    "text": "Code\nlibrary(knitr)\n## Global options\noptions(max.print=\"80\")\nopts_chunk$set(echo=TRUE,\n               cache=FALSE,\n               prompt=FALSE,\n               tidy=FALSE,\n               comment=NA,\n               message=FALSE,\n               warning=FALSE,\n               options(scipen=999))\nopts_knit$set(width=75)\n\n# Packages utilitaires\nlibrary(dplyr)\n\n\n\nAttaching package: 'dplyr'\n\n\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n\n\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n\n\nCode\nlibrary(rmdformats)\n\n# Packages graphiques\nlibrary(ggplot2)\nlibrary(RColorBrewer)\n\n#packages cartographiques \nlibrary(sf)\n\n\nLinking to GEOS 3.11.0, GDAL 3.5.3, PROJ 9.1.0; sf_use_s2() is TRUE\n\n\nCode\nlibrary(leaflet)\nlibrary(htmlwidgets)\nlibrary(htmltools)"
  },
  {
    "objectID": "07-carto-leaflet.html#premiers-pas",
    "href": "07-carto-leaflet.html#premiers-pas",
    "title": "Carto-leaflet",
    "section": "Premiers pas",
    "text": "Premiers pas\n\nOBJECTIFS : Ce cours propose de fournir les bases élémentaires du logiciel Leaflet. Il est très largement inspiré d’un article d’Elena Salette publié sur l’excellent site de formation ThinkR et intitulé Cartographie interactive : comment visualiser mes données spatiales de manière dynamique avec leaflet ?\n\n\nBUG WARNING : Il peut arriver que la transformation du fichier .Rmd en .html ne s’opère pas et que vous voyiez apparaître le message d’erreur suivant RMarkdown cannot knit: html_dependency not found. Ce message d’erreur persiste même après avoir corrigé le code… ce qui est très pénible. Après avoir cherché sur les forums de discussion, j’ai trouvé une première réponse sur stackoverflow qui consiste simplement à aller sur la flèche descendnate à droite du bouton knitr et effectuer un clear knitr cache avant de relancer le Knitr. Apparemment ça marche, sans que je sache bien pourquoi. Mais la solution la plus efficace semble être d’insérer une option cache=FALSE dans les options globales du fichier Markdown. Cela va sans doute un peu ralentir l’affichage des pages HTML,mais évite les problèmes. On pourra toujours rétablir cache=TRUE si nécessaire\n\nNotre premier objectif très limité sera de construire une carte interactive utilisant le fonds de carte OpenStreetMap que l’on pourra zoomer en avant ou en arrière. La carte comportera la localisation de la place de la gare à Sucy-en-Brie avec une “épingle” de localisation comportant une photographie de la gare et un petit texte de promotion de celle-ci.\n\nLancement avec leaflet()\nNous allons avoir besoin des packages suivants :\n\nleaflet puisque c’est l’objet même du cours !\ndplyr afin de pouvoir construire des programmes utilisant des pipes %&gt;%\nsf pour charger des fonds de carte de différents types (points, lignes polygones)\nhtmltools et htmlwidgets pour ajouter des popups interactifs sur notre carte\n\nPour vérifier que le package leaflet est bien installé, nous créons une première carte (vide !)\n\n\nCode\nmap &lt;- leaflet()\n\nmap\n\n\n\n\n\n\nEt il n’y a … RIEN ! si ce n’est un bouton de zoom\n\n\nRemplissage avec addTiles()\nOn ajoute sur ce fond de carte vide des “tuiles” cartographiques qui sont des images se modifiant selon l’échelle pour apporter plus ou moins de détails. Par défaut, le fonds de carte de référence est le fonds OpenStreetMap\n\n\nCode\nlibrary(leaflet)\n\nmap &lt;- leaflet() %&gt;%\n          addTiles()\n\nmap\n\n\n\n\n\n\nLa carte est désormais interactive et on peut effectuer des zooms ou se déplacer.\n\n\nCalage avec setView()\nNous allons ensuite choisir un point de référence, par exemple la place de la gare à Sucy-en-Brie. Pour trouver les coordonnées de latitude et longitude, la solution la plus simple est d’utiliser Google Maps puis de zoomer sur la zone d’étude et enfin d’effectuer un click droit avec la souris sur le point dont on cherche les coordonnées pour obtenir dans un popup les coordonnées recherchées :\n\n\n\ncoordonnnées du Vieux Port à Marseille\n\n\nOn peut alors procéder à une double opération de centrage de notre carte et de définition d’une échelle d’observation afin que la carte produite par leafletcouvre bien la zone qui nous intéresse. Cette double opération est réalisée à l’aide de la fonction setView() assortie des trois paramètre suivants :\n\nlng = pour la longitude\nlat = pour la latitude\nzoom = pour le degré d’aggrandissement de la carte de 1 pour le Monde entier à 20 pour une vision ulra locale\n\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n          addTiles() %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 17)\n\nmap\n\n\n\n\n\n\nUne fois qu’on a vérifié le centrage avec un zoom fort (ici 17), on peut refaire la carte en utilisant un zoom plus faible, par exemple un zoom de 12 permettant de visualiser toute la commune de Sucy et les communes voisines.\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n          addTiles() %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 12)\n\nmap\n\n\n\n\n\n\n\n\nPersonalisation avec addProviderTiles()\nLes tuiles OpenStreetMap qui servent de fonds de carte par défaut peuvent être remplacés par des tuiles personalisées fournies par des producteurs publics ou privés. On peut obtenir la liste des tuiles disponibles en tapant providers dans la console de R studio et les tester une par une. Mais il est souvent plus simple et plus rapide d’aller visualiser les tuiles disponibles sur ce site web où l’on peut centrer le monde sur sa zone d’étude et voir ce que donnent les différentes familles de tuiles.\nA titre d’exemple, les tuiles OpenTopoMap permettent de voir la carte topographique de type IGN en couleur :\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('OpenTopoMap') %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 17)\n\nmap\n\n\n\n\n\n\nLa couche Esri.WorldTopoMap fournit également une imagerie précise mais de couleurs plus neutre que les tuiles OpenTopoMap ou OpenStreetMap , ce qui sera intéressant si on superspose des marqueurs de couleur vive.\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 17)\nmap\n\n\n\n\n\n\n\n\nAffichage d’un point avec addMarkers()\nL’usage le plus fréquent de leafletconsiste à ajouter des éléments de localisation ponctuelle appelés markerset de rendre ces objets ponctuels interactifs avec l’ouverture de fenêtres popupslorsqu’on clique dessus avec la souris. On va donc voir pas à pas comment construire de telles cartes interactives en partant du cas le plus simple (marqueur unique) pour aller vers les cas plus complexes (ensemble de marqueurs de taille, couleur et formes différentes).\nNous allons commencer par indiquer l’emplacement du Vieux Port sur notre carte précédente à l’aide de la fonction addMarkers() :\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 15) %&gt;%\n            addMarkers(lat = 43.29512, lng=5.37417)\nmap\n\n\n\n\n\n\nOn constate que le marqueur donne bien la position choisi mais n’est pas interactif. Il faut ajouter plus de paramètres pour assurer l’interactivité.\n\n\nAjout d’un labelou d’un popup\nOn peut définir deux comportements d’un marker selon que la souris ne fait que passer dessus (label) ou selon que l’utilisateur effectue un click sur marker et déclenche l’ouverture d’une fenêtre (popup). Dans sa version la plus simple, l’interactivité consiste à ajouter une chaîne de caractère à ces deux paramètres.\n\n\nCode\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 15) %&gt;%\n            addMarkers(lat = 43.29512, lng=5.37417,\n                      # En passant la souris\n                      label = \"Le Vieux Port\", \n                      # En cliquant sur l'icone\n                       popup = \"Le Vieux Port de Marseille est le plus beau port du Monde\")\nmap\n\n\n\n\n\n\n\n\nAmélioration du popup\nMais on peut faire beaucoup mieux, notamment pour la fenêtre popupqui peut prendre la forme d’une mini-page web dont on fixe le contenu en html avec la fonction paste0() et les dimensions avec le sous-paramètre popupOptions().\n\n\nCode\n# Préparation de la fenêtre Popup\n    my_popup = paste0(\n      \"&lt;b&gt; LE VIEUX PORT DE MARSEILLE\",\n      \"&lt;/b&gt;&lt;br/&gt;&lt;img src=https://upload.wikimedia.org/wikipedia/commons/thumb/7/74/Marseille_Old_Port.jpg/520px-Marseille_Old_Port.jpg width='200px'&gt;&lt;br/&gt;\",\n      \"Le Vieux-Port de Marseille est le plus beau port du monde !\")\n\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n          setView(lat = 43.29512, lng=5.37417, zoom = 15) %&gt;%\n            addMarkers(lat = 43.29512, lng=5.37417,\n                      # En passant la souris\n                      label = \"Le Vieux Port\", \n                      # En cliquant sur l'icone\n                       popup = my_popup,\n                     # Quelques options de la popup\n                        popupOptions = \n                      list(maxHeight = 150, maxWidth = 200))\nmap\n\n\n\n\n\n\n\n\nProlongements\nEt voila, le tour est joué. Il faut maintenant réfléchir à la façon de construire une carte comportant un ensemble d’épingles similaires avec des couleurs ou des formes différentes, des messages différents, des photographies variées … Il ne sera alors évidemment pas possible d’ajouter une commande addMarkers() pour chaque épingle si la carte en comporte des centaines.\nSi vous avez bien compris ce cours, vous pourrez trouver des réponses en lisant de façon autonome le reste de l’article dont nous nous somme inspiré : Cartographie interactive : comment visualiser mes données spatiales de manière dynamique avec leaflet ?"
  },
  {
    "objectID": "07-carto-leaflet.html#carte-des-logements-sociaux",
    "href": "07-carto-leaflet.html#carte-des-logements-sociaux",
    "title": "Carto-leaflet",
    "section": "Carte des logements sociaux",
    "text": "Carte des logements sociaux\nNous allons prendre comme exemple le fichier de localisation des logements sociaux regroupés par adresse à Marseille que nous avons préparé lors de l’étape précédente. Nous transformons la projection en latitude-longitude (EPSG 4326)\n\n\nCode\ndon&lt;-readRDS(file = \"res/logt_adr.RDS\")\ndon&lt;-st_transform(don, 4326)\n\n\nOn peut à ce stade sélectionner un type particulier de logement. Ici, on va par exemple s’intéresser aux logements de type PLAI destinés aux plus pauvres.\n\n\nCode\nsel&lt;-don %&gt;% filter(fin_min ==\"1.PLAI\")\n\n\n\nCartographie des localisations\nOn commence par créer une carte des localisations des adresses avec AddCircleMarkers()\n\n\nCode\n# Réalisation de la carte\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n            setView(lat = 43.29512, lng=5.37417, zoom = 12) %&gt;%\n             addCircleMarkers(data=sel)\n\nmap\n\n\n\n\n\n\n\n\nRéglage de la taille des cercles\nOn règle la taille des cercles en fonction du nombre de logements\n\n\nCode\n# Calcul du diamètre des cercles\n  sel$myradius &lt;-10*sqrt(sel$nb/max(sel$nb,na.rm=T))\n  \n# Réalisation de la carte\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n            setView(lat = 43.29512, lng=5.37417, zoom = 12) %&gt;%\n  \n             addCircleMarkers(data=sel,\n                              radius= ~myradius,    # diamètre\n                              stroke=FALSE,         # pas de bordure           \n                              fillOpacity = 0.5)    # opacité \n            \n                              \n\nmap\n\n\n\n\n\n\n\n\nRéglage de la couleur des cercles\nOn décide ensuite de faire varier la couleur des cercles en fonction de l’ancienneté des logements sociaux.\n\n\nCode\n# Calcul du diamètre des cercles\n  sel$myradius &lt;-10*sqrt(sel$nb/max(sel$nb,na.rm=T))\n\n# Choix des classes \n    mycut&lt;-c(1800, 1950, 1960,1970,1980,2000,2010,2020)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal &lt;- colorBin('Spectral', \n                       reverse = T,\n                       sel$anc_moy,\n                       bins=mycut)\n  \n# Réalisation de la carte\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n            setView(lat = 43.29512, lng=5.37417, zoom = 12) %&gt;%\n  \n             addCircleMarkers(data=sel,\n                              radius= ~myradius,    # diamètre\n                              stroke=TRUE,          # bordure   \n                              weight=1  ,           # épaisseur de la bordure\n                              color= \"black\",      # couleur de la bordure\n                              opacity = 0.7  ,       # opacité de la bordure \n                              fillOpacity = 0.5,    # opacité \n                              fillColor = ~mypal(anc_moy)\n                              )    %&gt;%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Ancienneté\",\n                      values =~anc_moy, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\n\nAjout d’un popup d’information\nOn rajoute un popup pour afficher toutes les informations sur chaque terrain\n\n\nCode\n# Calcul du diamètre des cercles\n  sel$myradius &lt;-10*sqrt(sel$nb/max(sel$nb,na.rm=T))+3\n\n# Choix des classes \n    mycut&lt;-c(1900, 1950, 1960,1970,1980,2000,2010,2020)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal &lt;- colorBin('Spectral', \n                       reverse = T,\n                       sel$anc_moy,\n                       bins=mycut)\n# Préparation des popups\n      mypopups &lt;- lapply(seq(nrow(sel)), function(i) {\n      paste0(  paste(\"nb. logements    : \" ,sel$nb[i]), '&lt;br&gt;', \n               paste(\"surf. moyenne    : \", round(sel$sup_moy[i],0), \" m2\"), '&lt;br&gt;',\n               paste(\"ancienneté       : \" ,round(sel$anc_moy[i],0)), '&lt;br&gt;',\n               paste(\"financement      : \" ,sel$fin_min[i]), '&lt;br&gt;',\n               paste(\"type énergétique : \" ,sel$ene_min[i])\n               )\n            \n            })\n      mypopups&lt;-lapply(mypopups, htmltools::HTML)  \n      \n  \n# Réalisation de la carte\nmap &lt;- leaflet() %&gt;% \n            addProviderTiles('Esri.WorldTopoMap') %&gt;%\n            setView(lat = 43.29512, lng=5.37417, zoom = 12) %&gt;%\n  \n             addCircleMarkers(data=sel,\n                              radius= ~myradius,       # diamètre\n                              stroke=TRUE,             # bordure   \n                              weight=1  ,              # épaisseur de la bordure\n                              color= \"black\",          # couleur de la bordure\n                              opacity = 0.7  ,         # opacité de la bordure \n                              fillOpacity = 0.5,       # opacité du remplissage\n                              fillColor = ~mypal(anc_moy), # couleur de remplissage\n                               popup = mypopups,       # Popup !\n                              )    %&gt;%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Ancienneté\",\n                      values =~anc_moy, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\n\nChoix des tuiles\nOn fait varier les tuiles pour offrir la possibilité de visualiser la position des maisons sur un plan ou sur une photo aérienne.\n\n\nCode\n# Calcul du diamètre des cercles\n  sel$myradius &lt;-10*sqrt(sel$nb/max(sel$nb,na.rm=T))+3\n\n# Choix des classes \n    mycut&lt;-c(1900, 1950, 1960,1970,1980,2000,2010,2020)\n    \n# Choix de la palette (c'est une fonction !)\n   mypal &lt;- colorBin('Spectral', \n                       reverse = T,\n                       sel$anc_moy,\n                       bins=mycut)\n# Préparation des popups\n      mypopups &lt;- lapply(seq(nrow(sel)), function(i) {\n      paste0(  paste(\"nb. logements    : \" ,sel$nb[i]), '&lt;br&gt;', \n               paste(\"surf. moyenne    : \", round(sel$sup_moy[i],0), \" m2\"), '&lt;br&gt;',\n               paste(\"ancienneté       : \" ,round(sel$anc_moy[i],0)), '&lt;br&gt;',\n               paste(\"financement      : \" ,sel$fin_min[i]), '&lt;br&gt;',\n               paste(\"type énergétique : \" ,sel$ene_min[i])\n               )\n            \n            })\n      mypopups&lt;-lapply(mypopups, htmltools::HTML)  \n      \n  \n# Réalisation de la carte\nmap &lt;- leaflet() %&gt;% \n               # Tuiles\n               addTiles(group = \"OSM \") %&gt;%\n               addProviderTiles('Esri.WorldTopoMap', group = \"ESRI topo.\") %&gt;%\n               addProviderTiles('Esri.WorldImagery', group = \"ESRI photo.\") %&gt;%\n              # Contrôle des tuiles\n               addLayersControl( baseGroups = c(\"OSM\",\"ESRI topo.\",\"ESRI photo.\"),\n                                 position = \"bottomright\") %&gt;%\n            setView(lat = 43.29512, lng=5.37417, zoom = 12) %&gt;%\n  \n             addCircleMarkers(data=sel,\n                              radius= ~myradius,       # diamètre\n                              stroke=TRUE,             # bordure   \n                              weight=1  ,              # épaisseur de la bordure\n                              color= \"black\",          # couleur de la bordure\n                              opacity = 0.7  ,         # opacité de la bordure \n                              fillOpacity = 0.5,       # opacité du remplissage\n                              fillColor = ~mypal(anc_moy), # couleur de remplissage\n                               popup = mypopups,       # Popup !\n                              )    %&gt;%\n              addLegend(data = sel,\n                      pal = mypal, \n                      title = \"Ancienneté\",\n                      values =~anc_moy, \n                      position = 'topright') \n            \n                              \n\nmap\n\n\n\n\n\n\n\n\nSauvegarde du résultat\non peut transformer le résultat en widget html pour réutilisation dans une page web\n\n\nCode\nsaveWidget(map, \"img/widget.html\",selfcontained = T)"
  }
]